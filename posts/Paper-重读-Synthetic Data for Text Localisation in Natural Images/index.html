<!DOCTYPE html>
<html lang=zh-CN data-theme="light">
	
<script src="/js/plugins/toggleTheme.js"></script>

	<script>
		setTheme();
	</script>
	<head>
		
<title>Paper-重读-Synthetic Data for Text Localisation in Natural Images | Zi-Zi's Journey</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/images/icon/favicon.ico">
<link href="/css/plugins/print.css" media="print" rel="stylesheet" />

<link rel="stylesheet" href="/css/index.css">



<meta name="keywords" content="数据集,Python,论文,代码复现,">
<meta name="description" content="论文阅读。">



<script src="/js/plugins/jquery.min.js"></script>


<script src="/js/plugins/hljs.min.js"></script>


<script src="/js/plugins/init.js"></script>


<script src="/js/plugins/hide.js"></script>


<script src="/js/plugins/tabs.js"></script>



    



    
<script src="/js/plugins/alert-title.js"></script>

    
<link rel="stylesheet" href="/css/plugins/github-alerts/github-base.css">

    
<link rel="stylesheet" href="/css/plugins/github-alerts/github-colors-dark-class.css">

    
<link rel="stylesheet" href="/css/plugins/github-alerts/github-colors-light.css">






    

	<meta name="generator" content="Hexo 6.1.0"></head>

	<body>
		<header class="sticky-header">
	<nav>
		<div class="nav-left">
			<a href="/" class="logo">
				<img no-lazy src="/images/headers_icon/logo.webp" alt="Quieter">
			</a>
			<ul class="breadcrumb" id="breadcrumb"></ul>
		</div>
		<div class="nav-right">
			<ul>
				
					<li>
						<a href="/">
						  主页
						</a>
					</li>
				
					<li>
						<a href="/categories">
						  类别
						</a>
					</li>
				
					<li>
						<a href="/tags">
						  标签
						</a>
					</li>
				
					<li>
						<a href="/archives">
						  归档
						</a>
					</li>
				
					<li>
						<a href="/galleries">
						  相册
						</a>
					</li>
				
					<li>
						<a href="/links">
						  链接
						</a>
					</li>
				
					<li>
						<a href="/about">
						  关于
						</a>
					</li>
								  
			</ul>
		</div>
		<div class="nav-right-close">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
				<path fill="none" d="M0 0h24v24H0z" />
				<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
			</svg>
		</div>

		<div class="sidebar">
    <div class="topo">
        <p>Zi-Zi's Journey</p>
    </div>
    <ul>
        
        <li>
            <a href="/">
                主页
            </a>
        </li>
        
        <li>
            <a href="/categories">
                类别
            </a>
        </li>
        
        <li>
            <a href="/tags">
                标签
            </a>
        </li>
        
        <li>
            <a href="/archives">
                归档
            </a>
        </li>
        
        <li>
            <a href="/galleries">
                相册
            </a>
        </li>
        
        <li>
            <a href="/links">
                链接
            </a>
        </li>
        
        <li>
            <a href="/about">
                关于
            </a>
        </li>
        
    </ul>
    <div class="sidebar-footer">
        
        <a target="_blank" rel="noopener" href="https://weibo.com/u/5020307235">
            <img no-lazy src="/images/bottom_icon/Weibo.webp" alt="Quieter">
        </a>
        
        <a target="_blank" rel="noopener" href="https://tieba.baidu.com/home/main?id=tb.1.ff6d2775.vFH7wrdW2ZjPCmyBHJcjnA">
            <img no-lazy src="/images/bottom_icon/Tieba.webp" alt="Quieter">
        </a>
        
        <a target="_blank" rel="noopener" href="https://space.bilibili.com/11547880">
            <img no-lazy src="/images/bottom_icon/Bilibili.webp" alt="Quieter">
        </a>
        
        <a target="_blank" rel="noopener" href="https://github.com/GZ-Metal-Cell">
            <img no-lazy src="/images/bottom_icon/github.webp" alt="Quieter">
        </a>
        
    </div>
</div>
<div class='shelter'>
    <script>
        $(function() {
            $('.nav-right-close > svg').click(function() {
                $('.sidebar').animate({
                    right: "0"
                }, 500);
                $('.shelter').fadeIn("slow");
            
                var element = $('.topo');
                element.addClass('custom-style');
            
                var links = null;
                if ("") {
                    links = "".split(',');
                } else {
                    links = "/images/random_top_img/01.webp,/images/random_top_img/02.webp,/images/random_top_img/03.webp,/images/random_top_img/04.webp,/images/random_top_img/05.webp,/images/random_top_img/06.webp,/images/random_top_img/07.webp,/images/random_top_img/08.webp,/images/random_top_img/09.webp,/images/random_top_img/10.webp,/images/random_top_img/11.webp,/images/random_top_img/12.webp,/images/random_top_img/13.webp,/images/random_top_img/14.webp,/images/random_top_img/15.webp,/images/random_top_img/16.webp,/images/random_top_img/17.webp,/images/random_top_img/18.webp,/images/random_top_img/19.webp,/images/random_top_img/20.webp,/images/random_top_img/21.webp,/images/random_top_img/22.webp,/images/random_top_img/23.webp,/images/random_top_img/24.webp,/images/random_top_img/25.webp,/images/random_top_img/26.webp,/images/random_top_img/27.webp,/images/random_top_img/28.webp,/images/random_top_img/29.webp,/images/random_top_img/30.webp,/images/random_top_img/31.webp,/images/random_top_img/32.webp,/images/random_top_img/33.webp,/images/random_top_img/34.webp,/images/random_top_img/35.webp,/images/random_top_img/36.webp,/images/random_top_img/37.webp,/images/random_top_img/38.webp,/images/random_top_img/39.webp,/images/random_top_img/40.webp,/images/random_top_img/41.webp,/images/random_top_img/42.webp,/images/random_top_img/43.webp,/images/random_top_img/44.webp,/images/random_top_img/45.webp,/images/random_top_img/46.webp,/images/random_top_img/47.webp,/images/random_top_img/48.webp,/images/random_top_img/49.webp,/images/random_top_img/50.webp,/images/random_top_img/51.webp,/images/random_top_img/52.webp,/images/random_top_img/53.webp,/images/random_top_img/54.webp,/images/random_top_img/55.webp,/images/random_top_img/56.webp,/images/random_top_img/57.webp".split(',');
                }
            
                var randomLink = links[Math.floor(Math.random() * links.length)];
                element.css('background-image', "url('" + randomLink + "')");
            });
          
            $('.shelter').click(function(e) {
                $('.sidebar').animate({
                    right: "-100%"
                }, 500);
                $('.shelter').fadeOut("slow");
            });
        });      
    </script>
</div>
	</nav>

	
		<div class="header-background"></div>
	

	<script>
		const name = 'post';
		const ul = document.querySelectorAll('.nav-right ul')[0];
		const lis = ul.querySelectorAll('li');

		if (name == 'home') {
			lis[0].classList.add('select');
		} else {
			for (let i = 0; i < lis.length; i++) {
				const li = lis[i];
				const a = li.querySelector('a');
				if (name === a.href.split('/')[3]) {
					li.classList.add('select');
				}
			}
		}
	</script>
	
	<script>
		var element = document.querySelector('.header-background');
		if(element) {
			element.classList.add('custom-style');
			var links = null;
			if("")
			{
				links = "".split(',');
			} else
			{
				links = "/images/random_top_img/01.webp,/images/random_top_img/02.webp,/images/random_top_img/03.webp,/images/random_top_img/04.webp,/images/random_top_img/05.webp,/images/random_top_img/06.webp,/images/random_top_img/07.webp,/images/random_top_img/08.webp,/images/random_top_img/09.webp,/images/random_top_img/10.webp,/images/random_top_img/11.webp,/images/random_top_img/12.webp,/images/random_top_img/13.webp,/images/random_top_img/14.webp,/images/random_top_img/15.webp,/images/random_top_img/16.webp,/images/random_top_img/17.webp,/images/random_top_img/18.webp,/images/random_top_img/19.webp,/images/random_top_img/20.webp,/images/random_top_img/21.webp,/images/random_top_img/22.webp,/images/random_top_img/23.webp,/images/random_top_img/24.webp,/images/random_top_img/25.webp,/images/random_top_img/26.webp,/images/random_top_img/27.webp,/images/random_top_img/28.webp,/images/random_top_img/29.webp,/images/random_top_img/30.webp,/images/random_top_img/31.webp,/images/random_top_img/32.webp,/images/random_top_img/33.webp,/images/random_top_img/34.webp,/images/random_top_img/35.webp,/images/random_top_img/36.webp,/images/random_top_img/37.webp,/images/random_top_img/38.webp,/images/random_top_img/39.webp,/images/random_top_img/40.webp,/images/random_top_img/41.webp,/images/random_top_img/42.webp,/images/random_top_img/43.webp,/images/random_top_img/44.webp,/images/random_top_img/45.webp,/images/random_top_img/46.webp,/images/random_top_img/47.webp,/images/random_top_img/48.webp,/images/random_top_img/49.webp,/images/random_top_img/50.webp,/images/random_top_img/51.webp,/images/random_top_img/52.webp,/images/random_top_img/53.webp,/images/random_top_img/54.webp,/images/random_top_img/55.webp,/images/random_top_img/56.webp,/images/random_top_img/57.webp".split(',');
			}
			var randomLink = links[Math.floor(Math.random() * links.length)];
			element.style.backgroundImage = "url('" + randomLink + "')";
		}
	</script>

	
<script src="/js/plugins/breadcrumb.js"></script>

	<script>
		var menus_title = [];
		
			menus_title.push({home: '主页'});
		
			menus_title.push({categories: '类别'});
		
			menus_title.push({tags: '标签'});
		
			menus_title.push({archives: '归档'});
		
			menus_title.push({galleries: '相册'});
		
			menus_title.push({links: '链接'});
		
			menus_title.push({about: '关于'});
		
		
			
				postsBreadcrumb(
					document.getElementById('breadcrumb'),
					"类别",
					"/categories",
					"学习",
					"/categories/学习",
					1
				);
			
		
	</script>
</header>

<div class="main-wrapper">
    <main class="post">
        <header class="main-header">
	
		
			
				
<link rel="stylesheet" href="/css/plugins/fancybox.css">

				
<script src="/js/plugins/fancybox.umd.js"></script>

				
<script src="/js/plugins/fancybox.js"></script>

			
			<div class="post-header-background-content">
				<ul class="post-header-tag">
					
						
							<li><a href="/tags/数据集"><span>数据集</span></a></li>
						
							<li><a href="/tags/Python"><span>Python</span></a></li>
						
							<li><a href="/tags/论文"><span>论文</span></a></li>
						
							<li><a href="/tags/代码复现"><span>代码复现</span></a></li>
						
					
				</ul>
				
				<h1>Paper-重读-Synthetic Data for Text Localisation in Natural Images</h1>
		
				
					<div class="post-header-desc">
						<svg t="1714702231661" class="icon" viewBox="0 0 1024 1024" version="1.1"
						xmlns="http://www.w3.org/2000/svg" p-id="1154" xmlns:xlink="http://www.w3.org/1999/xlink"
						width="20" height="20">
						<path
							d="M778.24 117.76A46.08 46.08 0 0 1 824.32 163.84v430.08c0 8.4992-4.13696 16.01536-10.50624 20.6848l-0.24576 0.2048L587.5712 846.09024a35.84 35.84 0 0 1-61.48096-25.06752v-220.9792a46.08 46.08 0 0 1 46.08-46.08l200.94976-0.02048V168.96h-522.24v686.08H389.12c13.25056 0 24.1664 10.07616 25.47712 22.97856l0.12288 2.62144c0 14.1312-11.4688 25.6-25.6 25.6h-143.36A46.08 46.08 0 0 1 199.68 860.16V163.84A46.08 46.08 0 0 1 245.76 117.76h532.48z m-26.78784 487.38304h-174.16192v178.176l174.16192-178.176z m-45.19936-169.94304a25.6 25.6 0 0 1 0 51.2H307.2a25.6 25.6 0 0 1 0-51.2h399.0528z m0-122.88a25.6 25.6 0 0 1 0 51.2H307.2a25.6 25.6 0 0 1 0-51.2h399.0528z"
							fill="#ffffff" p-id="1155"></path>
						</svg>
						<p>论文阅读。</p>
					</div>
				
		
				<div class="post-header-info">
					<svg t="1604839279282" class="icon" viewBox="0 0 1024 1024" version="1.1"
					xmlns="http://www.w3.org/2000/svg" p-id="2901" width="20" height="20">
						<path
							d="M513 956.3c-247.7 0-448-200.3-448-448S265.3 66.2 513 66.2s448 200.3 448 448-200.3 442.1-448 442.1z m0-830.9c-212.2 0-388.8 170.7-388.8 388.8C124.2 726.3 294.9 903 513 903c212.2 0 388.8-170.7 388.8-388.8S725.2 125.4 513 125.4z m0 430.2c-94.2 0-170.7-76.5-170.7-170.7S418.8 207.8 513 207.8s170.7 76.5 170.7 170.7S607.2 555.6 513 555.6z m0-289.1c-64.6 0-112 52.8-112 112s47.4 117.9 112 117.9 112-52.8 112-112-47.4-117.9-112-117.9z m0 689.8c-135.7 0-259-58.7-341.9-158.9l-11.8-17.8 11.8-17.8c76.5-117.9 206.2-188.5 347.8-188.5 135.7 0 265 64.6 341.9 182.6l11.8 17.8-11.8 17.8C778 897.1 648.7 956.3 513 956.3zM230.3 773.2C300.9 849.7 406.9 897 513 897c112 0 218.1-47.4 288.6-129.8-70.5-88.2-170.7-135.6-282.7-135.6s-218.1 53.3-288.6 141.6z"
							p-id="2902" fill="#ffffff"></path>
					</svg>
					<div class="post-header-info-author">
						<a href="/about">Zi-Zi</a>
					</div>
					
						<div class="post-header-info-categories">
							
								<a href="/categories/学习">学习</a>
							
						</div>
					
					<time>2023/09/05 14:39:00</time>
				</div>
		
				
					<div class="post-header-stat">
						<svg version="1.0" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
						viewBox="0 0 200 200" enable-background="new 0 0 200 200" xml:space="preserve" width="20" height="20">
							<path fill="#FFFFFF" d="M187.2,165.6c0,2.6-2.1,4.7-4.7,4.7H17.5c-2.6,0-4.7-2.1-4.7-4.7s2.1-4.7,4.7-4.7h165.1
								C185.2,160.9,187.2,163,187.2,165.6z"/>
							<path fill="#FFFFFF" d="M17.5,29.7c2.6,0,4.7,2.1,4.7,4.7v131.2c0,2.6-2.1,4.7-4.7,4.7s-4.7-2.1-4.7-4.7V34.4
								C12.8,31.8,14.9,29.7,17.5,29.7z M77.9,91.5c1.8,1.8,1.8,4.8,0,6.6l-39.8,39.8c-1.9,1.8-4.9,1.7-6.6-0.2c-1.7-1.8-1.7-4.6,0-6.4
								l39.8-39.8C73.1,89.6,76,89.6,77.9,91.5z M169.9,70.2c1.6,2.1,1.1,5-0.9,6.5c0,0,0,0,0,0l-64.2,48.2c-2.1,1.5-5,1.1-6.6-0.9
								c-1.6-2.1-1.1-5,0.9-6.5c0,0,0,0,0,0l64.2-48.2C165.4,67.7,168.3,68.1,169.9,70.2L169.9,70.2z"/>
							<path fill="#FFFFFF" d="M104.6,124.5c-1.8,1.8-4.8,1.8-6.6,0L71.6,98.1c-1.8-1.8-1.8-4.8,0-6.6c1.8-1.8,4.8-1.8,6.6,0l26.3,26.3
								C106.4,119.6,106.4,122.6,104.6,124.5C104.6,124.4,104.6,124.4,104.6,124.5z"/>
						</svg>
		
						
							
<script src="/js/plugins/wordCount.js"></script>

							<p class="post-count">文字数：---</p>
						
		
						
							<p id="busuanzi_container_page_pv" style='display:none;'>阅读数：<span id="busuanzi_value_page_pv"></span></p>
						
					</div>
				
			</div>
		
	
</header>
        <div class="post-content article-container">
            <article class="post-content-info">
                <h1 id="%E8%B5%84%E6%BA%90" tabindex="-1">资源</h1>
<ul>
<li>
<p>原文：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1604.06646v1">[1604.06646v1] Synthetic Data for Text Localisation in Natural Images (arxiv.org)</a></p>
</li>
<li>
<p>PaddleOCR：<a target="_blank" rel="noopener" href="https://arxiv.org/abs/1604.06646v1">[1604.06646v1] Synthetic Data for Text Localisation in Natural Images (arxiv.org)</a></p>
</li>
<li>
<p>代码：<a target="_blank" rel="noopener" href="https://github.com/ankush-me/SynthText">ankush-me/SynthText: Code for generating synthetic text images as described in “Synthetic Data for Text Localisation in Natural Images”, Ankush Gupta, Andrea Vedaldi, Andrew Zisserman, CVPR 2016. (github.com)</a></p>
</li>
</ul>
<h1 id="%E5%8E%9F%E6%96%87" tabindex="-1">原文</h1>
<h2 id="abstract" tabindex="-1" id="Abstract">Abstract</h2>
<ol>
<li>提出了一个数据集合成引擎，以一种自然的方式将合成文本覆盖到现有的背景图像上，考虑到局部 3D 场景的几何形状。</li>
<li>一个新的全卷积回归网络 FRCN，解决文本检测问题。在 ICDAR 2013 上获得 84.2% 的 F-Score。</li>
</ol>
<h2 id="1-introduction" tabindex="-1" id="1-Introduction">1 Introduction</h2>
<ol>
<li>
<p>介绍了文本识别的意义，检测管道的性能成为文本识别的新瓶颈:在一个文本识别网络中，正确裁剪单词的识别准确率为 98%，而端到端文本识别 f 值仅为 69%。</p>
</li>
<li>
<p>提出了一种新的数据集合成引擎，生成的数据集称为 SynthText in the Wild。</p>
</li>
<li>
<p>还提出了一个文本检测模型，<s>但是这玩意太老了估计现在不会用了</s>。</p>
</li>
</ol>
<h3 id="1.1-related-work" tabindex="-1" id="1-1-Related-Work">1.1 Related Work</h3>
<ol>
<li>介绍了基于 CNN 的目标检测</li>
<li>介绍了合成数据集</li>
<li>介绍了数据增强的方法</li>
</ol>
<h2 id="2-synthetic-text-in-the-wild" tabindex="-1" id="2-Synthetic-Text-in-the-Wild">2 Synthetic Text in the Wild</h2>
<p>我们提出的合成引擎：</p>
<ol>
<li>真实</li>
<li>自动化</li>
<li>快速</li>
</ol>
<p>文本生成管道：</p>
<ol>
<li>
<p>获取合适的文本和图像样本</p>
</li>
<li>
<p>根据局部颜色和纹理线索将图像分割成连续的区域</p>
</li>
<li>
<p>使用 CNN 获得密集的逐像素深度图</p>
</li>
<li>
<p>对每个相邻区域估计一个局部表面法线</p>
</li>
<li>
<p>根据区域的颜色选择文本和可选的轮廓的颜色</p>
</li>
<li>
<p>使用随机选择的字体渲染文本样本，并根据局部表面方向进行转换</p>
</li>
<li>
<p>使用泊松图像编辑将文本融入场景中</p>
</li>
</ol>
<p><img src="F3.png" alt="png"></p>
<center>（上，从左到右）：<br/>(1) 无文本实例的 RGB 输入图像。<br/>(2) 预测密集深度图（越暗的区域越近）。<br/>
(3) 颜色和纹理 gPb-UCM 分段。<br/>(4) 过滤区域:对适合文本的区域随机上色;那些不合适的保留其原始图像像素。<br/>(下)：四个合成的场景文本图像，在单词级别具有轴对齐的边界框注释。</center>
<h3 id="2.1.-text-and-image-sources" tabindex="-1" id="2-1-Text-and-Image-Sources">2.1. Text and Image Sources</h3>
<ul>
<li>
<p>文本从 Newsgroups20 数据集中提取单词、行和段落。</p>
</li>
<li>
<p>为了增加多样性，从谷歌图像搜索提取了 8000 张图像，人工检查丢弃包含文本的图像。</p>
</li>
</ul>
<h3 id="2.2.-segmentation-and-geometry-estimation" tabindex="-1" id="2-2-Segmentation-and-Geometry-Estimation">2.2. Segmentation and Geometry Estimation</h3>
<p><img src="F4.png" alt="png"></p>
<center>局部颜色/纹理敏感的位置。<br/>(左)合成文本数据集的示例图像。请注意，文本被限制在街道上的台阶范围内。<br/>(右)相比之下，这张图片中的文本位置并没有考虑到局部区域的线索。</center>
<ul>
<li>在真实图像中，文本往往包含在定义良好的区域(例如一个标志)。我们通过要求文本包含在以统一颜色和纹理为特征的区域中来近似此约束。将 gPb-UCM 轮廓层次的阈值设定为 0.11，从而获得区域。</li>
<li>在自然图像中，文字往往被画在表面的顶部（例如一个标志或一个杯子）。为了在我们的合成数据中近似类似的效果，文本根据局部表面法线进行透视转换。首先使用 CNN 对上述分割的区域预测密集深度图，然后使用 RANSAC 对其拟合平面 facet，从而自动估计法线。</li>
<li>将文本对齐到估计的区域方向，步骤如下:
<ul>
<li>首先，使用估计的平面法线将图像区域轮廓扭曲为正面平行视图;</li>
<li>然后，在前平行区域拟合一个矩形;</li>
<li>最后，文本与这个矩形的大边(“width”)对齐。</li>
<li>当在同一区域放置多个文本实例时，将检查文本蒙版是否相互碰撞，以避免将它们放在彼此的顶部</li>
</ul>
</li>
<li>并不是所有的分割区域都适合文本放置——区域不应该太小，有一个极端的长宽比，或者表面法线与观看方向正交;所有这些区域都在这个阶段进行过滤。此外，还过滤了纹理过多的区域，其中纹理的程度是通过 RGB 图像中的三阶导数的强度来衡量的。</li>
</ul>
<hr>
<ul>
<li>
<p>使用 CNN 来估计深度的替代方法是使用 RGBD 图像数据集，这是一个容易出错的过程。我们更喜欢估计一个不完美的深度图，因为:</p>
<ul>
<li>
<p>它基本上允许使用任何场景类型的背景图像，而不仅仅是那些可用的 RGBD 数据，</p>
</li>
<li>
<p>因为公开可用的 RGBD 数据集都具有很强的限制。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2.3.-text-rendering-and-image-composition" tabindex="-1" id="2-3-Text-Rendering-and-Image-Composition">2.3. Text Rendering and Image Composition</h3>
<ul>
<li>
<p>一旦确定了文本的位置和方向，文本就会被分配一种颜色。文本的调色板是从 IIIT5K 单词数据集中裁剪的单词图像中学习的。每个裁剪的单词图像中的像素使用 K-means 划分为两组，产生颜色对，其中一种颜色近似前景（文本）颜色，另一种颜色近似背景。在渲染新文本时，选择背景颜色与目标图像区域最匹配的颜色对（在 Lab 色彩空间中使用 L2-norm），并使用相应的前景颜色来渲染文本。</p>
</li>
<li>
<p>大约 20% 的文本实例被随机选择为具有边框。边界颜色被选择为与前景颜色相同，其值通道增加或减少，或者被选择为前景和背景颜色的平均值。</p>
</li>
<li>
<p>为了保持合成文本图像中的光照梯度，我们使用泊松图像编辑将文本混合到基础图像上。</p>
</li>
</ul>
<h2 id="3.-a-fast-text-detection-network" tabindex="-1" id="3-A-Fast-Text-Detection-Network">3. A Fast Text Detection Network</h2>
<h3 id="3.1.-architecture" tabindex="-1" id="3-1-Architecture">3.1. Architecture</h3>
<p>​    不看了。</p>
<h2 id="4.-evaluation" tabindex="-1" id="4-Evaluation">4. Evaluation</h2>
<h3 id="4.1.-datasets" tabindex="-1" id="4-1-Datasets">4.1. Datasets</h3>
<ul>
<li>SynthText in the Wild</li>
<li>ICDAR Datasets</li>
<li>Street View Text</li>
</ul>
<h3 id="4.2.-text-localisation-experiments" tabindex="-1" id="4-2-Text-Localisation-Experiments">4.2. Text Localisation Experiments</h3>
<p>​    好使。</p>
<h3 id="4.3.-synthetic-dataset-evaluation" tabindex="-1" id="4-3-Synthetic-Dataset-Evaluation">4.3. Synthetic Dataset Evaluation</h3>
<p>​    我们生成了三个复杂程度越来越高的合成训练数据集：</p>
<ol>
<li>文本被放置在图像中的随机位置</li>
<li>限制于局部颜色和纹理边界</li>
<li>扭曲视角以匹配局部场景深度(同时也尊重如上(2)中的局部颜色和纹理边界)。</li>
</ol>
<p>​    数据集的所有其他方面都保持不变——例如文本词典、背景图像、颜色分布。</p>
<h3 id="4.4.-end-to-end-text-spotting" tabindex="-1" id="4-4-End-to-End-Text-Spotting">4.4. End-to-End Text Spotting</h3>
<p>​    在文本识别领域的表现。</p>
<h3 id="4.5.-timings" tabindex="-1" id="4-5-Timings">4.5. Timings</h3>
<p>​    速度不错！</p>
<h2 id="5.-conclusion" tabindex="-1" id="5-Conclusion">5. Conclusion</h2>
<p>​    设计的模型在现有的数据集里不好使，但是在合成数据集的帮助下就很好使了。</p>
<h2 id="a.appendix" tabindex="-1" id="A-Appendix">A.Appendix</h2>
<h3 id="a.1.-variation-in-fonts%2C-colors-and-sizes" tabindex="-1" id="A-1-Variation-in-Fonts-Colors-and-Sizes">A.1. Variation in Fonts, Colors and Sizes</h3>
<p><img src="A1.png" alt="png"></p>
<p>​    下面的图片显示了同一文本 “vamos!” 的合成文本渲染。</p>
<p>​    沿着行，文本呈现在大致相同的位置和相同的背景图像上，但字体、颜色和大小不同。</p>
<h3 id="a.2.-poisson-editing-vs.-alpha-blending" tabindex="-1" id="A-2-Poisson-Editing-vs-Alpha-Blending">A.2. Poisson Editing vs. Alpha Blending</h3>
<p><img src="A2.png" alt="png"></p>
<p>​    简单 alpha 混合（下一行）和泊松编辑（上一行）的比较。</p>
<p>​    泊松编辑保留局部照明梯度和纹理细节。</p>
<h3 id="a.3.-synthtext-in-the-wild" tabindex="-1" id="A-3-SynthText-in-the-Wild">A.3. SynthText in the Wild</h3>
<p><img src="A3.png" alt="png"></p>
<p>​    这些图像显示了不同字体、颜色、大小的文本实例，带有边框和阴影，背景不同，并根据局部几何形状进行转换，并约束于颜色和文本的局部连续区域。GT 的 BBox 用红色标记。</p>
<h3 id="a.4.-icdar-2013-detections" tabindex="-1" id="A-4-ICDAR-2013-Detections">A.4. ICDAR 2013 Detections</h3>
<p><img src="A4.png" alt="png"></p>
<p>​    ICDAR 2013 数据集上来自 “FCRNall + multi-flit”（上行）和来自 Jaderberg 等人（下行）的检测示例。精度，召回率和 F 测量值 (P / R / F) 显示在每个图像的顶部。</p>
<h3 id="a.5.-street-view-text-(svt)-detections" tabindex="-1" id="A-5-Street-View-Text-SVT-Detections">A.5. Street View Text (SVT) Detections</h3>
<p><img src="A5.png" alt="png"></p>
<p>​    在“FCRNall + multi-flit”街景文本 (SVT) 数据集上的检测示例（上一行）和来自 Jaderberg 等人的检测示例（下一行）。</p>
<p>​    精度，召回率和 F 测量值 (P / R / F) 在每张图像的顶部表示:这两种方法在这些图像上的精度都为 1 （除了一个由于缺少地基真值注释的情况）。</p>
<h2 id="%E6%95%B0%E6%8D%AE%E9%9B%86%E8%A7%A3%E6%9E%90" tabindex="-1" id="数据集解析">数据集解析</h2>
<p>​    从 <a target="_blank" rel="noopener" href="https://academictorrents.com/details/2dba9518166cbd141534cbf381aa3e99a087e83c">Synthetic Data for Text Localisation in Natural Images - Academic Torrents</a> 下载 <code>SynthText.zip</code>，解压之：</p>
<p><img src="C1.png" alt="png"></p>
<p>​    其中每一个文件夹里包含一个场景，里面存放着若干图片，<code>gt.mat</code> 是这些图片的注释。</p>
<p>​    关于 <code>gt.mat</code> 里的解析：<a target="_blank" rel="noopener" href="https://blog.csdn.net/jizhidexiaoming/article/details/130008864">SynthText文本数据详细解析_synthtext数据集_Mr.Q的博客-CSDN博客</a></p>
<p>​    使用 python 读取 <code>gt.mat</code> 文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scipy.io <span class="hljs-keyword">as</span> sio<br><br><span class="hljs-comment"># 读取MAT文件</span><br>data = sio.loadmat(<span class="hljs-string">r&#x27;D:\dataset\SynthText\SynthText\gt.mat&#x27;</span>)<br></code></pre></td></tr></table></figure>
<p>​    包含如下属性：</p>
<ul>
<li>imnames：图片路径</li>
<li>txt：文本</li>
<li>wordBB：单词级标注框</li>
<li>charBB：字符级标注框</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(data[<span class="hljs-string">&#x27;imnames&#x27;</span>][<span class="hljs-number">0</span>]), <span class="hljs-built_in">len</span>(data[<span class="hljs-string">&#x27;txt&#x27;</span>][<span class="hljs-number">0</span>]), <span class="hljs-built_in">len</span>(data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>]), <span class="hljs-built_in">len</span>(data[<span class="hljs-string">&#x27;charBB&#x27;</span>][<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">(858750, 858750, 858750, 858750)<br></code></pre></td></tr></table></figure>
<p>数据集可视化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>index = <span class="hljs-number">92</span><br><br>file_dir = <span class="hljs-string">r&#x27;D:/dataset/SynthText/SynthText/&#x27;</span><br><br>image_path = os.path.join(file_dir, data[<span class="hljs-string">&#x27;imnames&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>])<br><br>image_origin = cv2.imread(image_path)<br>image_bbox = image_origin.copy()<br>image_cbox = image_origin.copy()<br>height, width, _ = image_origin.shape<br><br><br>txt = []<br><span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(data[<span class="hljs-string">&#x27;txt&#x27;</span>][<span class="hljs-number">0</span>][index]):<br>    txt.extend(element.split())<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], np.ndarray):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])):  <span class="hljs-comment"># bbox</span><br>        x =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>][:, i]]<br>        y =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">1</span>][:, i]]<br>        points = np.array([x, y], np.int32).T<br>        transcriptions = txt[i]<br><br>        cv2.polylines(image_bbox, [points], isClosed=<span class="hljs-literal">True</span>, color=(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points:<br>            cv2.circle(image_bbox, (p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">min</span>(height, width) / <span class="hljs-number">150</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), -<span class="hljs-number">1</span>)<br><br>        cv2.putText(image_bbox, transcriptions, (x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>] - <span class="hljs-built_in">int</span>(<span class="hljs-built_in">min</span>(height, width) / <span class="hljs-number">150</span>)), cv2.FONT_HERSHEY_SIMPLEX,<br>                    <span class="hljs-built_in">min</span>(height, width) / <span class="hljs-number">1000</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">min</span>(height, width) / <span class="hljs-number">500</span>))<br><span class="hljs-keyword">else</span>:<br>    x =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>]]<br>    y =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">1</span>]]<br>    points = np.array([x, y], np.int32).T<br>    transcriptions = txt[<span class="hljs-number">0</span>]<br><br>    cv2.polylines(image_bbox, [points], isClosed=<span class="hljs-literal">True</span>, color=(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points:<br>        cv2.circle(image_bbox, (p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">min</span>(height, width) / <span class="hljs-number">150</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), -<span class="hljs-number">1</span>)<br><br>    cv2.putText(image_bbox, transcriptions, (x[<span class="hljs-number">0</span>], y[<span class="hljs-number">0</span>] - <span class="hljs-built_in">int</span>(<span class="hljs-built_in">min</span>(height, width) / <span class="hljs-number">150</span>)), cv2.FONT_HERSHEY_SIMPLEX,<br>                <span class="hljs-built_in">min</span>(height, width) / <span class="hljs-number">1000</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">min</span>(height, width) / <span class="hljs-number">500</span>))<br>    <br><span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data[<span class="hljs-string">&#x27;charBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], np.ndarray):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data[<span class="hljs-string">&#x27;charBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])):  <span class="hljs-comment"># cbox</span><br>        x =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;charBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>][:, i]]<br>        y =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;charBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">1</span>][:, i]]<br>        points = np.array([x, y], np.int32).T<br><br>        cv2.polylines(image_cbox, [points], isClosed=<span class="hljs-literal">True</span>, color=(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points:<br>            cv2.circle(image_cbox, (p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">min</span>(height, width) / <span class="hljs-number">150</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), -<span class="hljs-number">1</span>)<br><span class="hljs-keyword">else</span>:<br>    x =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;charBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>]]<br>    y =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;charBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">1</span>]]<br>    points = np.array([x, y], np.int32).T<br><br>    cv2.polylines(image_cbox, [points], isClosed=<span class="hljs-literal">True</span>, color=(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), thickness=<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> points:<br>        cv2.circle(image_cbox, (p[<span class="hljs-number">0</span>], p[<span class="hljs-number">1</span>]), <span class="hljs-built_in">int</span>(<span class="hljs-built_in">min</span>(height, width) / <span class="hljs-number">150</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>), -<span class="hljs-number">1</span>)<br>        <br>fig, axes = plt.subplots(nrows=<span class="hljs-number">3</span>, ncols=<span class="hljs-number">1</span>, figsize=(<span class="hljs-number">32</span>, <span class="hljs-number">18</span>))<br>axes = axes.flatten()<br><br>axes[<span class="hljs-number">0</span>].imshow(cv2.cvtColor(image_origin, cv2.COLOR_BGR2RGB))<br>axes[<span class="hljs-number">0</span>].axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>axes[<span class="hljs-number">0</span>].set_title(<span class="hljs-string">&#x27;Origin: &#x27;</span> + data[<span class="hljs-string">&#x27;imnames&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>])<br><br>axes[<span class="hljs-number">1</span>].imshow(cv2.cvtColor(image_bbox, cv2.COLOR_BGR2RGB))<br>axes[<span class="hljs-number">1</span>].axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>axes[<span class="hljs-number">1</span>].set_title(<span class="hljs-string">&#x27;bbox&#x27;</span>)<br><br>axes[<span class="hljs-number">2</span>].imshow(cv2.cvtColor(image_cbox, cv2.COLOR_BGR2RGB))<br>axes[<span class="hljs-number">2</span>].axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>axes[<span class="hljs-number">2</span>].set_title(<span class="hljs-string">&#x27;cbox&#x27;</span>)<br><br>plt.tight_layout()<br>plt.show()<br></code></pre></td></tr></table></figure>
<p><img src="C2.png" alt="png"></p>
<h2 id="%E8%BD%AC%E6%8D%A2%E6%88%90-mindocr-%E5%8F%AF%E8%AF%BB%E7%9A%84-totaltext-%E5%BD%A2%E5%BC%8F" tabindex="-1" id="转换成-MindOCR-可读的-TotalText-形式">转换成 MindOCR 可读的 TotalText 形式</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><br>file_dir = <span class="hljs-string">r&#x27;D:/dataset/SynthText/SynthText/&#x27;</span><br>save_image_dir = <span class="hljs-string">r&#x27;D:/dataset/SynthText/SynthText/images&#x27;</span><br>save_label_dir = <span class="hljs-string">r&#x27;D:/dataset/SynthText/SynthText/Txts&#x27;</span><br><br><span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-number">858750</span>)):<br>    image_path = os.path.join(file_dir, data[<span class="hljs-string">&#x27;imnames&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>])<br>    shutil.copy(image_path, os.path.join(save_image_dir, <span class="hljs-string">&#x27;img&#x27;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&#x27;.jpg&#x27;</span>))<br>    <br>    string = <span class="hljs-string">&quot;&quot;</span><br>    txt = []<br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(data[<span class="hljs-string">&#x27;txt&#x27;</span>][<span class="hljs-number">0</span>][index]):<br>        txt.extend(element.split())<br><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], np.ndarray):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>])):  <span class="hljs-comment"># bbox</span><br>            x =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>][:, i]]<br>            y =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">1</span>][:, i]]<br>            points = np.array([x, y], np.int32).T<br>            transcriptions = txt[i]<br>    <span class="hljs-keyword">else</span>:<br>        x =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">0</span>]]<br>        y =  [<span class="hljs-built_in">int</span>(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> data[<span class="hljs-string">&#x27;wordBB&#x27;</span>][<span class="hljs-number">0</span>][index][<span class="hljs-number">1</span>]]<br>        points = np.array([x, y], np.int32).T<br>        transcriptions = txt[<span class="hljs-number">0</span>]<br>        <br>    string += <span class="hljs-string">&#x27;x: [[&#x27;</span><br>    string += <span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, x))<br>    string += <span class="hljs-string">&#x27;]], y: [[&#x27;</span><br>    string += <span class="hljs-string">&#x27; &#x27;</span>.join(<span class="hljs-built_in">map</span>(<span class="hljs-built_in">str</span>, y))<br>    string += <span class="hljs-string">&quot;]], ornt: [u&#x27;h&quot;</span><br>    string += <span class="hljs-string">&quot;&#x27;], transcriptions: [u&#x27;&quot;</span><br>    string += transcriptions<br>    string += <span class="hljs-string">&quot;&#x27;]\n&quot;</span><br>    <br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(os.path.join(save_dir, <span class="hljs-string">&quot;poly_gt_img&quot;</span> + <span class="hljs-built_in">str</span>(index) + <span class="hljs-string">&quot;.txt&quot;</span>), <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;UTF-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        file.write(string)<br></code></pre></td></tr></table></figure>
<h2 id="%E4%BB%A3%E7%A0%81" tabindex="-1" id="代码">代码</h2>
<p>​    从 <a target="_blank" rel="noopener" href="https://github.com/ankush-me/SynthText/tree/python3">ankush-me/SynthText at python3 (github.com)</a> 获取代码，在 Wsl2 下跑，装环境下见招拆招，总能跑的。</p>
<p>​    生成图片：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python gen.py --viz<br></code></pre></td></tr></table></figure>
<p>​    可视化结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">python visualize_results.py<br></code></pre></td></tr></table></figure>
<p><img src="C3.png" alt="png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">image name        :  hiking_125.jpg_0<br>  ** no. of chars :  69<br>  ** no. of words :  15<br>  ** text         :  [&#x27;&gt;&gt;Potvin&#x27; &#x27;someone\n wrong \ngetting&#x27; &#x27;cloud&#x27; &#x27;do with&#x27; &#x27;Calgary\nfinal&#x27;<br> &#x27;Re:&#x27; &#x27;I have&#x27; &#x27;a stud\nMorgan&#x27;]<br></code></pre></td></tr></table></figure>
<h1 id="%E8%AF%BB%E4%BB%A3%E7%A0%81%EF%BC%88%E5%A4%AA%E5%A4%9A%E4%BA%86%EF%BC%8C%E6%8C%91%E4%B8%80%E7%82%B9%E7%9C%8B%E5%90%A7%EF%BC%89" tabindex="-1">读代码（太多了，挑一点看吧）</h1>
<h2 id="gen.py" tabindex="-1" id="gen-py"><a target="_blank" rel="noopener" href="http://gen.py">gen.py</a></h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> h5py  <span class="hljs-comment"># 用于读写 HDF5 文件格式的数据</span><br><span class="hljs-keyword">import</span> os, sys, traceback  <span class="hljs-comment"># 用于进行文件和系统操作以及处理异常</span><br><span class="hljs-keyword">import</span> os.path <span class="hljs-keyword">as</span> osp  <span class="hljs-comment"># 用于处理文件路径</span><br><span class="hljs-keyword">from</span> synthgen <span class="hljs-keyword">import</span> *  <span class="hljs-comment"># 从 synthgen 模块导入所有内容。synthgen 模块包含了生成合成文本图像的相关函数和类</span><br><span class="hljs-keyword">from</span> common <span class="hljs-keyword">import</span> *  <span class="hljs-comment"># 从 common 模块导入所有内容。common 模块包含了一些通用的函数和常量。</span><br><span class="hljs-keyword">import</span> wget, tarfile  <span class="hljs-comment"># 导入 wget 和 tarfile 模块，用于下载和解压文件。</span><br><br><br><span class="hljs-comment"># Define some configuration variables:</span><br><span class="hljs-comment"># 要用于生成的图像数量（-1表示使用所有可用的图像）。</span><br>NUM_IMG = -<span class="hljs-number">1</span>  <span class="hljs-comment"># no. of images to use for generation (-1 to use all available):</span><br><span class="hljs-comment"># 每张图像使用的实例数量。</span><br>INSTANCE_PER_IMAGE = <span class="hljs-number">1</span> <span class="hljs-comment"># no. of times to use the same image</span><br><span class="hljs-comment"># 每张图像的最大处理时间（单位：秒）。</span><br>SECS_PER_IMG = <span class="hljs-number">5</span>  <span class="hljs-comment"># max time per image in seconds</span><br><br><span class="hljs-comment"># path to the data-file, containing image, depth and segmentation:</span><br>DATA_PATH = <span class="hljs-string">&#x27;data&#x27;</span>  <span class="hljs-comment"># 数据文件的路径</span><br>DB_FNAME = osp.join(DATA_PATH,<span class="hljs-string">&#x27;dset.h5&#x27;</span>)  <span class="hljs-comment"># 数据库文件的完整路径，由数据路径和数据库文件名组合而成。</span><br><span class="hljs-comment"># url of the data (google-drive public file):</span><br>DATA_URL = <span class="hljs-string">&#x27;http://www.robots.ox.ac.uk/~ankush/data.tar.gz&#x27;</span>  <span class="hljs-comment"># 数据的下载链接。</span><br>OUT_FILE = <span class="hljs-string">&#x27;results/SynthText.h5&#x27;</span>  <span class="hljs-comment"># 输出结果的文件路径。</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>():<br>  <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  Download the image,depth and segmentation data:</span><br><span class="hljs-string">  Returns, the h5 database.</span><br><span class="hljs-string">  &quot;&quot;&quot;</span><br>  <span class="hljs-comment"># 检查存储数据的 h5 文件是否存在，如果不存在则执行数据下载和解压的操作。</span><br>  <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> osp.exists(DB_FNAME):<br>    <span class="hljs-keyword">try</span>:<br>      <span class="hljs-comment"># 打印提示信息，显示数据下载链接和文件大小。</span><br>      colorprint(Color.BLUE,<span class="hljs-string">&#x27;\tdownloading data (56 M) from: &#x27;</span>+DATA_URL,bold=<span class="hljs-literal">True</span>)<br>      <span class="hljs-built_in">print</span>()<br>      sys.stdout.flush()<br>      <span class="hljs-comment"># 使用 wget.download() 函数下载数据文件，并指定下载得到的文件名为 &quot;data.tar.gz&quot;。</span><br>      out_fname = <span class="hljs-string">&#x27;data.tar.gz&#x27;</span><br>      wget.download(DATA_URL,out=out_fname)<br>      <span class="hljs-comment"># 打开 tar 文件并解压文件内容。</span><br>      tar = tarfile.<span class="hljs-built_in">open</span>(out_fname)<br>      tar.extractall()<br>      <span class="hljs-comment"># 关闭 tar 文件并删除压缩文件 &quot;data.tar.gz&quot;。</span><br>      tar.close()<br>      os.remove(out_fname)<br>      <span class="hljs-comment"># 打印提示信息，显示数据保存的路径。</span><br>      colorprint(Color.BLUE,<span class="hljs-string">&#x27;\n\tdata saved at:&#x27;</span>+DB_FNAME,bold=<span class="hljs-literal">True</span>)<br>      sys.stdout.flush()<br>    description: <span class="hljs-comment"># 下载出现异常，则打印数据未找到的错误信息，并退出程序。</span><br>      <span class="hljs-built_in">print</span> (colorize(Color.RED,<span class="hljs-string">&#x27;Data not found and have problems downloading.&#x27;</span>,bold=<span class="hljs-literal">True</span>))<br>      sys.stdout.flush()<br>      sys.exit(-<span class="hljs-number">1</span>)<br>  <span class="hljs-comment"># open the h5 file and return: 打开 h5 文件并以只读方式返回数据库对象。</span><br>  <span class="hljs-keyword">return</span> h5py.File(DB_FNAME,<span class="hljs-string">&#x27;r&#x27;</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_res_to_db</span>(<span class="hljs-params">imgname,res,db</span>):<br>  <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  将合成的文本图像实例及其相关元数据添加到数据集中。</span><br><span class="hljs-string">  Add the synthetically generated text image instance</span><br><span class="hljs-string">  and other metadata to the dataset.</span><br><span class="hljs-string">  :param imgname: 图像名称</span><br><span class="hljs-string">  :param res: 生成的合成文本图像实例</span><br><span class="hljs-string">  :param db: 数据库对象</span><br><span class="hljs-string">  &quot;&quot;&quot;</span><br>  ninstance = <span class="hljs-built_in">len</span>(res)  <span class="hljs-comment"># 计算生成的合成文本图像实例的数量</span><br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(ninstance):  <span class="hljs-comment"># 遍历每个实例</span><br>    <span class="hljs-comment"># 首先创建一个数据集（dataset）并将合成图像存储在其中，数据集名称由图像名称和实例索引组成（dname）</span><br>    dname = <span class="hljs-string">&quot;%s_%d&quot;</span>%(imgname, i)<br>    db[<span class="hljs-string">&#x27;data&#x27;</span>].create_dataset(dname,data=res[i][<span class="hljs-string">&#x27;img&#x27;</span>])<br>    <span class="hljs-comment"># 将字符边界框（charBB）和单词边界框（wordBB）作为属性添加到数据集中</span><br>    db[<span class="hljs-string">&#x27;data&#x27;</span>][dname].attrs[<span class="hljs-string">&#x27;charBB&#x27;</span>] = res[i][<span class="hljs-string">&#x27;charBB&#x27;</span>]<br>    db[<span class="hljs-string">&#x27;data&#x27;</span>][dname].attrs[<span class="hljs-string">&#x27;wordBB&#x27;</span>] = res[i][<span class="hljs-string">&#x27;wordBB&#x27;</span>]        <br>    <span class="hljs-comment"># db[&#x27;data&#x27;][dname].attrs[&#x27;txt&#x27;] = res[i][&#x27;txt&#x27;]</span><br>    L = res[i][<span class="hljs-string">&#x27;txt&#x27;</span>]<br>    L = [n.encode(<span class="hljs-string">&quot;ascii&quot;</span>, <span class="hljs-string">&quot;ignore&quot;</span>) <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> L]<br>    db[<span class="hljs-string">&#x27;data&#x27;</span>][dname].attrs[<span class="hljs-string">&#x27;txt&#x27;</span>] = L<br>    <span class="hljs-comment"># 返回更新后的数据库对象。</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>(<span class="hljs-params">viz=<span class="hljs-literal">False</span></span>):<br>  <span class="hljs-comment"># open databases: 打开数据集</span><br>  <span class="hljs-built_in">print</span> (colorize(Color.BLUE,<span class="hljs-string">&#x27;getting data..&#x27;</span>,bold=<span class="hljs-literal">True</span>))<br>  db = get_data()<br>  <span class="hljs-built_in">print</span> (colorize(Color.BLUE,<span class="hljs-string">&#x27;\t-&gt; done&#x27;</span>,bold=<span class="hljs-literal">True</span>))<br><br>  <span class="hljs-comment"># open the output h5 file: 打开输出 HDF5 文件</span><br>  out_db = h5py.File(OUT_FILE,<span class="hljs-string">&#x27;w&#x27;</span>)<br>  out_db.create_group(<span class="hljs-string">&#x27;/data&#x27;</span>)<br>  <span class="hljs-built_in">print</span> (colorize(Color.GREEN,<span class="hljs-string">&#x27;Storing the output in: &#x27;</span>+OUT_FILE, bold=<span class="hljs-literal">True</span>))<br><br>  <span class="hljs-comment"># get the names of the image files in the dataset:</span><br>  <span class="hljs-comment"># 获取数据集中的图像名称列表</span><br>  imnames = <span class="hljs-built_in">sorted</span>(db[<span class="hljs-string">&#x27;image&#x27;</span>].keys())<br>  N = <span class="hljs-built_in">len</span>(imnames)<br>  <span class="hljs-keyword">global</span> NUM_IMG<br>  <span class="hljs-keyword">if</span> NUM_IMG &lt; <span class="hljs-number">0</span>:  <span class="hljs-comment"># -1 表示使用所有可用的图像</span><br>    NUM_IMG = N<br>  start_idx,end_idx = <span class="hljs-number">0</span>,<span class="hljs-built_in">min</span>(NUM_IMG, N)  <span class="hljs-comment"># 设置开始和结束索引</span><br><br>  RV3 = RendererV3(DATA_PATH,max_time=SECS_PER_IMG)<br>  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(start_idx,end_idx):  <span class="hljs-comment"># 循环遍历每个图像</span><br>    imname = imnames[i]<br>    <span class="hljs-keyword">try</span>:<br>      <span class="hljs-comment"># get the image: 获取图像</span><br>      img = Image.fromarray(db[<span class="hljs-string">&#x27;image&#x27;</span>][imname][:])<br>      <span class="hljs-comment"># get the pre-computed depth: 获取深度信息</span><br>      <span class="hljs-comment"># 这里有 2 个深度估计值（表示为 2 个“通道”），这里我们使用第二个（在某些情况下，使用另一个可能很有用）：</span><br>      <span class="hljs-comment"># there are 2 estimates of depth (represented as 2 &quot;channels&quot;)</span><br>      <span class="hljs-comment"># here we are using the second one (in some cases it might be</span><br>      <span class="hljs-comment"># useful to use the other one):</span><br>      depth = db[<span class="hljs-string">&#x27;depth&#x27;</span>][imname][:].T<br>      depth = depth[:,:,<span class="hljs-number">1</span>]<br>      <span class="hljs-comment"># get segmentation: 获取分割信息</span><br>      seg = db[<span class="hljs-string">&#x27;seg&#x27;</span>][imname][:].astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>      area = db[<span class="hljs-string">&#x27;seg&#x27;</span>][imname].attrs[<span class="hljs-string">&#x27;area&#x27;</span>]<br>      label = db[<span class="hljs-string">&#x27;seg&#x27;</span>][imname].attrs[<span class="hljs-string">&#x27;label&#x27;</span>]<br><br>      <span class="hljs-comment"># re-size uniformly: 缩放到相同的大小</span><br>      sz = depth.shape[:<span class="hljs-number">2</span>][::-<span class="hljs-number">1</span>]<br>      img = np.array(img.resize(sz,Image.ANTIALIAS))<br>      seg = np.array(Image.fromarray(seg).resize(sz,Image.NEAREST))<br> <br>      <span class="hljs-built_in">print</span> (colorize(Color.RED,<span class="hljs-string">&#x27;%d of %d&#x27;</span>%(i,end_idx-<span class="hljs-number">1</span>), bold=<span class="hljs-literal">True</span>))<br>      <span class="hljs-comment"># 使用 RendererV3 生成器，将文本渲染到每个图像中，并将合成文本图像及其相关元数据添加到输出数据库中。</span><br>      res = RV3.render_text(img,depth,seg,area,label,<br>                            ninstance=INSTANCE_PER_IMAGE,viz=viz)<br>      <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(res) &gt; <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># non-empty : successful in placing text: 成功放置文字</span><br>        add_res_to_db(imname,res,out_db)<br>      <span class="hljs-comment"># visualize the output:</span><br>      <span class="hljs-keyword">if</span> viz:  <span class="hljs-comment"># 可视化输出结果</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;q&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>(colorize(Color.RED,<span class="hljs-string">&#x27;continue? (enter to continue, q to exit): &#x27;</span>,<span class="hljs-literal">True</span>)):<br>          <span class="hljs-keyword">break</span><br>    excerpt:<br>      traceback.print_exc()<br>      <span class="hljs-built_in">print</span> (colorize(Color.GREEN,<span class="hljs-string">&#x27;&gt;&gt;&gt;&gt; CONTINUING....&#x27;</span>, bold=<span class="hljs-literal">True</span>))<br>      <span class="hljs-keyword">continue</span><br>  db.close()<br>  out_db.close()<br><br><br><span class="hljs-keyword">if</span> __name__==<span class="hljs-string">&#x27;__main__&#x27;</span>:<br>  <span class="hljs-keyword">import</span> argparse<br>  parser = argparse.ArgumentParser(description=<span class="hljs-string">&#x27;Genereate Synthetic Scene-Text Images&#x27;</span>)<br>  parser.add_argument(<span class="hljs-string">&#x27;--viz&#x27;</span>,action=<span class="hljs-string">&#x27;store_true&#x27;</span>,dest=<span class="hljs-string">&#x27;viz&#x27;</span>,default=<span class="hljs-literal">False</span>,<span class="hljs-built_in">help</span>=<span class="hljs-string">&#x27;flag for turning on visualizations&#x27;</span>)<br>  args = parser.parse_args()<br>  main(args.viz)<br></code></pre></td></tr></table></figure>
<h2 id="synthgen.py" tabindex="-1" id="synthgen-py"><a target="_blank" rel="noopener" href="http://synthgen.py">synthgen.py</a></h2>
<blockquote>
<p>Main script for synthetic text rendering.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> __future__ <span class="hljs-keyword">import</span> division<br><span class="hljs-keyword">import</span> copy<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">import</span> h5py<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-comment">#import mayavi.mlab as mym</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> os.path <span class="hljs-keyword">as</span> osp<br><span class="hljs-keyword">import</span> scipy.ndimage <span class="hljs-keyword">as</span> sim<br><span class="hljs-keyword">import</span> scipy.spatial.distance <span class="hljs-keyword">as</span> ssd<br><span class="hljs-keyword">import</span> synth_utils <span class="hljs-keyword">as</span> su<br><span class="hljs-keyword">import</span> text_utils <span class="hljs-keyword">as</span> tu<br><span class="hljs-keyword">from</span> colorize3_poisson <span class="hljs-keyword">import</span> Colorize<br><span class="hljs-keyword">from</span> common <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> traceback, itertools<br></code></pre></td></tr></table></figure>
<h3 id="class-textregions()" tabindex="-1" id="class-TextRegions">class TextRegions()</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextRegions</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Get region from segmentation which are good for placing</span><br><span class="hljs-string">    text.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 只有当区域的宽度大于等于 minWidth 并且高度大于等于 minHeight 才会被认为是可行的文本区域。</span><br>    minWidth = <span class="hljs-number">30</span> <span class="hljs-comment">#px</span><br>    minHeight = <span class="hljs-number">30</span> <span class="hljs-comment">#px</span><br>    <span class="hljs-comment"># 只有当区域的宽度与高度之比介于 minAspect 和 maxAspect 之间时，才会被认为是可行的文本区域</span><br>    minAspect = <span class="hljs-number">0.3</span> <span class="hljs-comment"># w &gt; 0.3*h</span><br>    maxAspect = <span class="hljs-number">7</span><br>    <span class="hljs-comment"># 只有当区域的像素数大于或等于 minArea 时，才会被认为是可行的文本区域</span><br>    minArea = <span class="hljs-number">100</span> <span class="hljs-comment"># number of pix</span><br>    <span class="hljs-comment"># 只有当区域的像素数大于或等于 minArea 时，才会被认为是可行的文本区域</span><br>    pArea = <span class="hljs-number">0.60</span> <span class="hljs-comment"># area_obj/area_minrect &gt;= 0.6</span><br><br>    <span class="hljs-comment"># RANSAC planar fitting params:</span><br>    <span class="hljs-comment"># RANSAC 平面拟合的参数：</span><br>    <span class="hljs-comment"># 距离阈值。如果一个点到拟合平面的距离小于 dist_thresh，则该点被认为是内点。</span><br>    dist_thresh = <span class="hljs-number">0.10</span> <span class="hljs-comment"># m</span><br>    <span class="hljs-comment"># 内点数量的最小值。如果拟合平面的内点数量小于 num_inlier，则拟合失败。</span><br>    num_inlier = <span class="hljs-number">90</span><br>    <span class="hljs-comment"># RANSAC 拟合的迭代次数。每一次迭代都会随机选择一些点进行平面拟合。</span><br>    ransac_fit_trials = <span class="hljs-number">100</span><br>    <span class="hljs-comment"># 平面法向量的最小 z 分量。如果平面法向量的 z 分量低于 min_z_projection，则该平面被认为是垂直于摄像机视角的，因此不能用作文本区域。</span><br>    min_z_projection = <span class="hljs-number">0.25</span><br>    <span class="hljs-comment"># 用于筛选旋转后的文本区域的最小宽度，只有当它大于 minW 时才会被保留。</span><br>    minW = <span class="hljs-number">20</span><br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_rectified</span>(<span class="hljs-params">mask</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        用于过滤旋转后的文本区域，只有当其宽度和高度都不小于 TextRegions.minW 时才会被保留。</span><br><span class="hljs-string">        接收一个二值化的图像作为输入，其中 &quot;1&quot; 表示区域内的像素点，&quot;0&quot; 则表示背景。</span><br><span class="hljs-string">        mask : 1 where &quot;ON&quot;, 0 where &quot;OFF&quot;</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 计算出区域在垂直和水平方向上的投影，然后取其中位数。</span><br>        wx = np.median(np.<span class="hljs-built_in">sum</span>(mask,axis=<span class="hljs-number">0</span>))<br>        wy = np.median(np.<span class="hljs-built_in">sum</span>(mask,axis=<span class="hljs-number">1</span>))<br>        <span class="hljs-comment"># 如果两个中位数都大于等于 TextRegions.minW，则返回 True，否则返回 False。</span><br>        <span class="hljs-keyword">return</span> wx&gt;TextRegions.minW <span class="hljs-keyword">and</span> wy&gt;TextRegions.minW<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_hw</span>(<span class="hljs-params">pt,return_rot=<span class="hljs-literal">False</span></span>):<br>        <span class="hljs-comment"># 用于计算旋转矫正后的文本区域的宽度和高度</span><br>        pt = pt.copy()<br>        <span class="hljs-comment"># 使用 unrotate2d 方法进行旋转校正。这个方法通过计算区域的主轴角度，然后将区域旋转回水平方向。</span><br>        R = su.unrotate2d(pt)<br>        <span class="hljs-comment"># 计算区域坐标的中位数 mu，并将每个点减去中位数，以便将区域的中心移动到原点。</span><br>        mu = np.median(pt,axis=<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 函数应用旋转矩阵 R，将区域进行旋转，并再次将中心移回原来的位置。</span><br>        pt = (pt-mu[<span class="hljs-literal">None</span>,:]).dot(R.T) + mu[<span class="hljs-literal">None</span>,:]<br>        <span class="hljs-comment"># 计算旋转矫正后的区域的宽度和高度，分别等于区域坐标的最大值减去最小值。</span><br>        h,w = np.<span class="hljs-built_in">max</span>(pt,axis=<span class="hljs-number">0</span>) - np.<span class="hljs-built_in">min</span>(pt,axis=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">if</span> return_rot:<br>            <span class="hljs-comment"># 如果 return_rot 参数设置为 True，则函数还会返回旋转矩阵 R。</span><br>            <span class="hljs-keyword">return</span> h,w,R<br>        <span class="hljs-keyword">return</span> h,w<br> <br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">seg,area,label</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Apply the filter.</span><br><span class="hljs-string">        The final list is ranked by area.</span><br><span class="hljs-string">        应用过滤器对文本区域进行筛选和排序。</span><br><span class="hljs-string">        :seg: 分割图像</span><br><span class="hljs-string">        :area: 区域面积</span><br><span class="hljs-string">        :label: 区域标签</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 根据 TextRegions.minArea 将小于最小面积阈值的区域排除，并更新 good 和 area 的值</span><br>        good = label[area &gt; TextRegions.minArea]<br>        area = area[area &gt; TextRegions.minArea]<br>        filt,R = [],[]<br>        <span class="hljs-keyword">for</span> idx,i <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(good):<br>            <span class="hljs-comment"># 对每个符合要求的区域进行处理。函数首先根据区域的标签 i 生成相应的二值掩膜 mask</span><br>            mask = seg==i<br>            <span class="hljs-comment"># 使用 np.where 函数获取掩膜上非零像素的坐标，并将其保存到 xs 和 ys</span><br>            xs,ys = np.where(mask)<br>            <span class="hljs-comment"># 将坐标转换为浮点型的数组 coords</span><br>            coords = np.c_[xs,ys].astype(<span class="hljs-string">&#x27;float32&#x27;</span>)<br>            <span class="hljs-comment"># 利用 cv2.minAreaRect 函数计算出最小外接矩形 rect</span><br>            rect = cv2.minAreaRect(coords)          <br>            <span class="hljs-comment">#box = np.array(cv2.cv.BoxPoints(rect))</span><br>            <span class="hljs-comment"># 通过 cv2.boxPoints 函数从矩形中获取四个角点的坐标，保存在 box 中</span><br>            box = np.array(cv2.boxPoints(rect))<br>            <span class="hljs-comment"># 调用 TextRegions.get_hw 方法获取旋转矫正后的区域的宽度 w、高度 h 和旋转矩阵 rot</span><br>            h,w,rot = TextRegions.get_hw(box,return_rot=<span class="hljs-literal">True</span>)<br>            <span class="hljs-comment"># 依次判断以下条件：</span><br>            <span class="hljs-comment"># h &gt; TextRegions.minHeight：区域高度是否大于最小高度阈值；</span><br>            <span class="hljs-comment"># w &gt; TextRegions.minWidth：区域宽度是否大于最小宽度阈值；</span><br>            <span class="hljs-comment"># TextRegions.minAspect &lt; w/h &lt; TextRegions.maxAspect：区域宽高比是否在允许的范围内；</span><br>            <span class="hljs-comment"># area[idx]/w*h &gt; TextRegions.pArea：经过旋转后的区域面积是否大于面积阈值</span><br>            <span class="hljs-comment"># 上述条件全部满足，则将标记为 True，否则标记为 False</span><br>            f = (h &gt; TextRegions.minHeight <br>                <span class="hljs-keyword">and</span> w &gt; TextRegions.minWidth<br>                <span class="hljs-keyword">and</span> TextRegions.minAspect &lt; w/h &lt; TextRegions.maxAspect<br>                <span class="hljs-keyword">and</span> area[idx]/w*h &gt; TextRegions.pArea)<br>            <span class="hljs-comment"># 将结果保存到列表 filt 中</span><br>            filt.append(f)<br>            <span class="hljs-comment"># 将旋转矩阵 rot 保存到列表 R 中</span><br>            R.append(rot)<br><br>        <span class="hljs-comment"># filter bad regions:</span><br>        <span class="hljs-comment"># 根据 filt 的结果对不符合条件的区域进行过滤</span><br>        filt = np.array(filt)<br>        <span class="hljs-comment"># 更新 area 和 R</span><br>        area = area[filt]<br>        R = [R[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(R)) <span class="hljs-keyword">if</span> filt[i]]<br><br>        <span class="hljs-comment"># sort the regions based on areas:</span><br>        <span class="hljs-comment"># 根据区域面积的降序对区域进行排序，并更新 good 和 R</span><br>        aidx = np.argsort(-area)<br>        good = good[filt][aidx]<br>        R = [R[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> aidx]<br>        <span class="hljs-comment"># 返回一个字典 filter_info，包含了筛选后的文本区域的标签、旋转矩阵和面积信息</span><br>        filter_info = &#123;<span class="hljs-string">&#x27;label&#x27;</span>:good, <span class="hljs-string">&#x27;rot&#x27;</span>:R, <span class="hljs-string">&#x27;area&#x27;</span>: area[aidx]&#125;<br>        <span class="hljs-keyword">return</span> filter_info<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sample_grid_neighbours</span>(<span class="hljs-params">mask,nsample,step=<span class="hljs-number">3</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Given a HxW binary mask, sample 4 neighbours on the grid,</span><br><span class="hljs-string">        in the cardinal directions, STEP pixels away.</span><br><span class="hljs-string">        :mask: H * W 的二值掩膜</span><br><span class="hljs-string">        :nsample: 采样数量</span><br><span class="hljs-string">        :step: 采样间隔</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-number">2</span>*step &gt;= <span class="hljs-built_in">min</span>(mask.shape[:<span class="hljs-number">2</span>]):<br>            <span class="hljs-keyword">return</span> <span class="hljs-comment">#None</span><br>        <span class="hljs-comment"># 通过 np.where 函数找到二值掩膜中非零像素的坐标，并将其保存在 y_m 和 x_m 中</span><br>        y_m,x_m = np.where(mask)<br>        <span class="hljs-comment"># 创建一个和 mask 相同大小的全零矩阵 mask_idx，用于存储每个非零像素的索引</span><br>        mask_idx = np.zeros_like(mask,<span class="hljs-string">&#x27;int32&#x27;</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_m)):<br>            mask_idx[y_m[i],x_m[i]] = i<br>        <span class="hljs-comment"># 根据给定的步长 step，分别计算出向 x 正方向和负方向、y 正方向和负方向的邻域像素坐标，并保存在 xp、xn、yp 和 yn 中</span><br>        xp,xn = np.zeros_like(mask), np.zeros_like(mask)<br>        yp,yn = np.zeros_like(mask), np.zeros_like(mask)<br>        xp[:,:-<span class="hljs-number">2</span>*step] = mask[:,<span class="hljs-number">2</span>*step:]<br>        xn[:,<span class="hljs-number">2</span>*step:] = mask[:,:-<span class="hljs-number">2</span>*step]<br>        yp[:-<span class="hljs-number">2</span>*step,:] = mask[<span class="hljs-number">2</span>*step:,:]<br>        yn[<span class="hljs-number">2</span>*step:,:] = mask[:-<span class="hljs-number">2</span>*step,:]<br>        <span class="hljs-comment"># 通过逻辑与运算 &amp;，获取在四个方向上都存在的有效邻域像素，并保存在 valid 中</span><br>        valid = mask&amp;xp&amp;xn&amp;yp&amp;yn<br><br>        <span class="hljs-comment"># 通过 np.where 函数找到 valid 中非零像素的坐标，并将其保存在 ys 和 xs 中</span><br>        ys,xs = np.where(valid)<br>        <span class="hljs-comment"># 如果没有找到任何有效的像素，即 N == 0，则返回 None</span><br>        N = <span class="hljs-built_in">len</span>(ys)<br>        <span class="hljs-keyword">if</span> N==<span class="hljs-number">0</span>: <span class="hljs-comment">#no valid pixels in mask:</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-comment">#None</span><br>        <span class="hljs-comment"># 找到了有效的像素，函数会选择 nsample 个像素进行采样，其中 nsample 取值不超过 N</span><br>        nsample = <span class="hljs-built_in">min</span>(nsample,N)<br>        <span class="hljs-comment"># 调用 np.random.choice 函数在坐标索引 idx 中选取 nsample 个不重复的索引</span><br>        idx = np.random.choice(N,nsample,replace=<span class="hljs-literal">False</span>)<br>        <span class="hljs-comment"># 根据选取的索引，生成邻域矩阵 sample_idx，其形状为 (1+4)x2xNsample（2 表示 y 和 x 坐标）</span><br>        <span class="hljs-comment"># generate neighborhood matrix:</span><br>        <span class="hljs-comment"># (1+4)x2xNsample (2 for y,x)</span><br>        xs,ys = xs[idx],ys[idx]<br>        s = step<br>        X = np.transpose(np.c_[xs,xs+s,xs+s,xs-s,xs-s][:,:,<span class="hljs-literal">None</span>],(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>))<br>        Y = np.transpose(np.c_[ys,ys+s,ys-s,ys+s,ys-s][:,:,<span class="hljs-literal">None</span>],(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>))<br>        sample_idx = np.concatenate([Y,X],axis=<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 函数将邻域矩阵转换为邻域索引矩阵 mask_nn_idx,其形状为 5xNsample。</span><br>        mask_nn_idx = np.zeros((<span class="hljs-number">5</span>,sample_idx.shape[-<span class="hljs-number">1</span>]),<span class="hljs-string">&#x27;int32&#x27;</span>)<br>        <span class="hljs-comment"># 对于每个选取的邻域像素，通过查找 mask_idx 对应位置的值，将相应的索引存储到 mask_nn_idx 中</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(sample_idx.shape[-<span class="hljs-number">1</span>]):<br>            mask_nn_idx[:,i] = mask_idx[sample_idx[:,:,i][:,<span class="hljs-number">0</span>],sample_idx[:,:,i][:,<span class="hljs-number">1</span>]]<br>        <span class="hljs-comment"># 函数最终返回邻域索引矩阵 mask_nn_idx</span><br>        <span class="hljs-keyword">return</span> mask_nn_idx<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">filter_depth</span>(<span class="hljs-params">xyz,seg,regions</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        这段代码实现了根据给定的点云数据、分割结果和区域信息，对每个区域进行深度滤波的函数</span><br><span class="hljs-string">        :xyz: 点云坐标数据</span><br><span class="hljs-string">        :seg: 分割结果</span><br><span class="hljs-string">        :regions: 区域信息</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 创建了一个空字典 plane_info，用于保存满足条件的平面信息</span><br>        plane_info = &#123;<span class="hljs-string">&#x27;label&#x27;</span>:[],<br>                      <span class="hljs-string">&#x27;coeff&#x27;</span>:[],<br>                      <span class="hljs-string">&#x27;support&#x27;</span>:[],<br>                      <span class="hljs-string">&#x27;rot&#x27;</span>:[],<br>                      <span class="hljs-string">&#x27;area&#x27;</span>:[]&#125;<br>        <span class="hljs-keyword">for</span> idx,l <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(regions[<span class="hljs-string">&#x27;label&#x27;</span>]):<br>            <span class="hljs-comment"># 对于 regions 中的每个区域，利用区域标签 l 和分割结果 seg，生成对应的二值掩膜 mask</span><br>            mask = seg==l<br>            <span class="hljs-comment"># 调用 TextRegions.sample_grid_neighbours 函数，以 mask 为输入，使用 RANSAC 方法进行平面拟合，获取采样点集 pt_sample</span><br>            pt_sample = TextRegions.sample_grid_neighbours(mask,TextRegions.ransac_fit_trials,step=<span class="hljs-number">3</span>)<br>            <span class="hljs-comment"># 如果没有足够的点进行 RANSAC 拟合，则跳过该区域的处理</span><br>            <span class="hljs-keyword">if</span> pt_sample <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                <span class="hljs-keyword">continue</span> <span class="hljs-comment">#not enough points for RANSAC</span><br>            <span class="hljs-comment"># get-depths</span><br>            <span class="hljs-comment"># 从点云数据 xyz 中筛选出属于当前区域的点坐标 pt</span><br>            pt = xyz[mask]<br>            <span class="hljs-comment"># 调用 su.isplanar 函数，以点云数据 pt、采样点集 pt_sample，以及一些阈值参数为输入，进行平面检测。如果检测到平面，返回的 plane_model 中包含平面系数、支持点索引等信息。</span><br>            plane_model = su.isplanar(pt, pt_sample,<br>                                     TextRegions.dist_thresh,<br>                                     TextRegions.num_inlier,<br>                                     TextRegions.min_z_projection)<br>            <span class="hljs-comment"># 在平面检测结果存在且满足一些要求（例如深度阈值、内点数量等）的情况下，将平面信息存储到 plane_info 字典中的相应字段中。</span><br>            <span class="hljs-keyword">if</span> plane_model <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                plane_coeff = plane_model[<span class="hljs-number">0</span>]<br>                <span class="hljs-keyword">if</span> np.<span class="hljs-built_in">abs</span>(plane_coeff[<span class="hljs-number">2</span>])&gt;TextRegions.min_z_projection:<br>                    plane_info[<span class="hljs-string">&#x27;label&#x27;</span>].append(l)<br>                    plane_info[<span class="hljs-string">&#x27;coeff&#x27;</span>].append(plane_model[<span class="hljs-number">0</span>])<br>                    plane_info[<span class="hljs-string">&#x27;support&#x27;</span>].append(plane_model[<span class="hljs-number">1</span>])<br>                    plane_info[<span class="hljs-string">&#x27;rot&#x27;</span>].append(regions[<span class="hljs-string">&#x27;rot&#x27;</span>][idx])<br>                    plane_info[<span class="hljs-string">&#x27;area&#x27;</span>].append(regions[<span class="hljs-string">&#x27;area&#x27;</span>][idx])<br><br>        <span class="hljs-keyword">return</span> plane_info<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_regions</span>(<span class="hljs-params">xyz,seg,area,label</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        根据给定的点云数据、分割结果、区域面积和区域标签，获取文本区域</span><br><span class="hljs-string">        :xyz: 点云坐标数据</span><br><span class="hljs-string">        :seg: 分割结果</span><br><span class="hljs-string">        :area: 区域面积</span><br><span class="hljs-string">        :label: 数据标签</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 函数调用 TextRegions.filter 函数，以分割结果 seg、区域面积 area 和区域标签 label 为输入，对分割结果进行筛选，获取文本区域的初始信息，保存在变量 regions 中</span><br>        regions = TextRegions.<span class="hljs-built_in">filter</span>(seg,area,label)<br>        <span class="hljs-comment"># fit plane to text-regions:</span><br>        <span class="hljs-comment"># 调用 TextRegions.filter_depth 函数，以点云数据 xyz、分割结果 seg 和文本区域信息 regions 为输入，对每个区域进行深度滤波，获取满足条件的平面信息，更新存储平面信息的 regions 变量</span><br>        regions = TextRegions.filter_depth(xyz,seg,regions)<br>        <span class="hljs-comment"># 函数返回经过深度滤波后的文本区域信息 regions</span><br>        <span class="hljs-keyword">return</span> regions<br></code></pre></td></tr></table></figure>
<h2 id="colorize3_poisson.py" tabindex="-1" id="colorize3-poisson-py">colorize3_poisson.py</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <br><span class="hljs-keyword">import</span> scipy.interpolate <span class="hljs-keyword">as</span> si<br><span class="hljs-keyword">import</span> scipy.ndimage <span class="hljs-keyword">as</span> scim <br><span class="hljs-keyword">import</span> scipy.ndimage.interpolation <span class="hljs-keyword">as</span> sii<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> os.path <span class="hljs-keyword">as</span> osp<br><span class="hljs-comment">#import cPickle as cp</span><br><span class="hljs-keyword">import</span> _pickle <span class="hljs-keyword">as</span> cp<br><span class="hljs-comment">#import Image</span><br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">from</span> poisson_reconstruct <span class="hljs-keyword">import</span> blit_images<br><span class="hljs-keyword">import</span> pickle<br></code></pre></td></tr></table></figure>
<h3 id="sample_weighted()" tabindex="-1" id="sample-weighted">sample_weighted()</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sample_weighted</span>(<span class="hljs-params">p_dict</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    接收一个字典 p_dict，用于表示概率分布，其中键表示某个值，值表示对应的概率。函数首先获取概率分布中的键，并使用 np.random.choice 函数根据概率分布进行随机采样，返回所选的键</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    ps = p_dict.keys()<br>    <span class="hljs-keyword">return</span> ps[np.random.choice(<span class="hljs-built_in">len</span>(ps),p=p_dict.values())]<br></code></pre></td></tr></table></figure>
<h3 id="class-layer()" tabindex="-1" id="class-Layer">class Layer()</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Layer</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,alpha,color</span>):<br><br>        <span class="hljs-comment"># alpha for the whole image:</span><br>        <span class="hljs-comment"># 针对 alpha 参数，函数要求其维度为 2（二维矩阵）。然后获取 alpha 的形状，并保存在变量 [n, m] 中</span><br>        <span class="hljs-keyword">assert</span> alpha.ndim==<span class="hljs-number">2</span><br>        <span class="hljs-variable language_">self</span>.alpha = alpha<br>        [n,m] = alpha.shape[:<span class="hljs-number">2</span>]<br>        <span class="hljs-comment"># 针对 color 参数，函数将其转换为 uint8 类型的数组。</span><br>        color=np.atleast_1d(np.array(color)).astype(<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>        <span class="hljs-comment"># color for the image:</span><br>        <span class="hljs-comment"># 根据 color 的长度决定是灰度图还是彩色图，然后创建相应维度的颜色矩阵</span><br>        <span class="hljs-comment"># 如果 color 维度为 1，则表示整个图层都是固定颜色</span><br>        <span class="hljs-keyword">if</span> color.ndim==<span class="hljs-number">1</span>: <span class="hljs-comment"># constant color for whole layer</span><br>            ncol = color.size<br>            <span class="hljs-keyword">if</span> ncol == <span class="hljs-number">1</span> : <span class="hljs-comment">#grayscale layer</span><br>                <span class="hljs-variable language_">self</span>.color = color * np.ones((n,m,<span class="hljs-number">3</span>),<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>            <span class="hljs-keyword">if</span> ncol == <span class="hljs-number">3</span> : <br>                <span class="hljs-variable language_">self</span>.color = np.ones((n,m,<span class="hljs-number">3</span>),<span class="hljs-string">&#x27;uint8&#x27;</span>) * color[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:]<br>        <span class="hljs-comment"># 如果 color 维度为 2，表示是灰度图，将其转换为三通道的颜色矩阵</span><br>        <span class="hljs-keyword">elif</span> color.ndim==<span class="hljs-number">2</span>: <span class="hljs-comment"># grayscale image</span><br>            <span class="hljs-variable language_">self</span>.color = np.repeat(color[:,:,<span class="hljs-literal">None</span>],repeats=<span class="hljs-number">3</span>,axis=<span class="hljs-number">2</span>).copy().astype(<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>        <span class="hljs-comment"># 如果 color 维度为 3，表示是彩色图，直接保存为颜色矩阵</span><br>        <span class="hljs-keyword">elif</span> color.ndim==<span class="hljs-number">3</span>: <span class="hljs-comment">#rgb image</span><br>            <span class="hljs-variable language_">self</span>.color = color.copy().astype(<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>        <span class="hljs-comment"># 如果以上情况都不满足，则抛出异常</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span> (color.shape)<br>            <span class="hljs-keyword">raise</span> excerption(<span class="hljs-string">&quot;color datatype not understood&quot;</span>)<br></code></pre></td></tr></table></figure>
<h3 id="class-fontcolor()" tabindex="-1" id="class-FontColor">class FontColor()</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">FontColor</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, col_file</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        这是一个构造函数，用于创建 FontColor 对象并初始化对象的属性</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(col_file,<span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            使用 open() 函数打开名为 col_file 的文件，并将其指定为二进制模式读取（&#x27;rb&#x27;）</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            <span class="hljs-comment">#self.colorsRGB = cp.load(f)</span><br>            <span class="hljs-comment"># 创建一个 _Unpickler 对象 u，用于反序列化从文件中读取的数据</span><br>            u = pickle._Unpickler(f)<br>            <span class="hljs-comment"># 设置 Unpickler 的编码方式为 &#x27;latin1&#x27;，以确保正确解析文件中的数据</span><br>            u.encoding = <span class="hljs-string">&#x27;latin1&#x27;</span><br>            <span class="hljs-comment"># 调用 Unpickler 对象的 load() 方法，从文件中加载数据并将其存储在变量 p 中</span><br>            p = u.load()<br>            <span class="hljs-comment"># 将加载的数据赋值给对象的属性 colorsRGB，该属性存储颜色数据</span><br>            <span class="hljs-variable language_">self</span>.colorsRGB = p<br>        <span class="hljs-comment"># 计算颜色数据的行数，并将结果存储在对象的属性 ncol 中</span><br>        <span class="hljs-variable language_">self</span>.ncol = <span class="hljs-variable language_">self</span>.colorsRGB.shape[<span class="hljs-number">0</span>]<br><br>        <span class="hljs-comment"># convert color-means from RGB to LAB for better nearest neighbour</span><br>        <span class="hljs-comment"># computations:</span><br>        <span class="hljs-comment"># 从颜色数据中提取 RGB 通道的数据，并将其转换为 LAB 颜色空间</span><br>        <span class="hljs-variable language_">self</span>.colorsLAB = np.r_[<span class="hljs-variable language_">self</span>.colorsRGB[:,<span class="hljs-number">0</span>:<span class="hljs-number">3</span>], <span class="hljs-variable language_">self</span>.colorsRGB[:,<span class="hljs-number">6</span>:<span class="hljs-number">9</span>]].astype(<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>        <span class="hljs-comment"># 使用 OpenCV 的 cvtColor() 函数将 RGB 颜色数据转换为 LAB 颜色空间，并调整维度以去除多余的维度</span><br>        <span class="hljs-variable language_">self</span>.colorsLAB = np.squeeze(cv.cvtColor(<span class="hljs-variable language_">self</span>.colorsLAB[<span class="hljs-literal">None</span>,:,:],cv.COLOR_RGB2Lab))<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sample_normal</span>(<span class="hljs-params">self, col_mean, col_std</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        sample from a normal distribution centered around COL_MEAN </span><br><span class="hljs-string">        with standard deviation = COL_STD.</span><br><span class="hljs-string">        这是一个用于从正态分布中采样颜色的方法。它接受两个参数，col_mean 和 col_std，分别表示正态分布的均值和标准差</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用 np.random.randn() 函数从标准正态分布中生成一个随机数，并乘以 col_std，再加上 col_mean，得到采样的颜色</span><br>        col_sample = col_mean + col_std * np.random.randn()<br>        <span class="hljs-comment"># 使用 np.clip() 函数将采样的颜色限制在 0 到 255 之间，然后使用 astype() 函数将其转换为整数类型 (uint8) 并返回</span><br>        <span class="hljs-keyword">return</span> np.clip(col_sample, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>).astype(<span class="hljs-string">&#x27;uint8&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sample_from_data</span>(<span class="hljs-params">self, bg_mat</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        bg_mat : this is a nxmx3 RGB image. 一个从数据集中采样颜色的方法。它接受一个参数bg_mat，表示一个RGB图像。</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        returns a tuple : (RGB_foreground, RGB_background)</span><br><span class="hljs-string">        each of these is a 3-vector.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 复制输入的背景图像，以备后续使用</span><br>        bg_orig = bg_mat.copy()<br>        <span class="hljs-comment"># 使用 OpenCV 的 cvtColor() 函数将 RGB 图像转换为 LAB 颜色空间</span><br>        bg_mat = cv.cvtColor(bg_mat, cv.COLOR_RGB2Lab)<br>        <span class="hljs-comment"># 将背景颜色矩阵重塑为一个二维数组，每一行代表一个像素点的颜色</span><br>        bg_mat = np.reshape(bg_mat, (np.prod(bg_mat.shape[:<span class="hljs-number">2</span>]),<span class="hljs-number">3</span>))<br>        <span class="hljs-comment"># 计算背景颜色矩阵的均值，得到一组代表整个背景图像颜色的平均值</span><br>        bg_mean = np.mean(bg_mat,axis=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-comment"># 计算每个颜色数据与背景颜色之间的欧氏距离，并存储在 norms 数组中</span><br>        norms = np.linalg.norm(<span class="hljs-variable language_">self</span>.colorsLAB-bg_mean[<span class="hljs-literal">None</span>,:], axis=<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># choose a random color amongst the top 3 closest matches:</span><br>        <span class="hljs-comment">#nn = np.random.choice(np.argsort(norms)[:3]) </span><br>        <span class="hljs-comment"># 找到欧氏距离最小的颜色数据的索引，即与背景颜色最相近的颜色数据</span><br>        nn = np.argmin(norms)<br><br>        <span class="hljs-comment"># nearest neighbour color:</span><br>        <span class="hljs-comment"># 获取与背景颜色最相近的颜色数据。</span><br>        data_col = <span class="hljs-variable language_">self</span>.colorsRGB[np.mod(nn,<span class="hljs-variable language_">self</span>.ncol),:]<br><br>        <span class="hljs-comment"># 使用 sample_normal 方法从颜色数据的前半部分采样一个颜色作为前景颜色。</span><br>        col1 = <span class="hljs-variable language_">self</span>.sample_normal(data_col[:<span class="hljs-number">3</span>],data_col[<span class="hljs-number">3</span>:<span class="hljs-number">6</span>])<br>        <span class="hljs-comment"># 使用 sample_normal 方法从颜色数据的后半部分采样一个颜色作为背景颜色。</span><br>        col2 = <span class="hljs-variable language_">self</span>.sample_normal(data_col[<span class="hljs-number">6</span>:<span class="hljs-number">9</span>],data_col[<span class="hljs-number">9</span>:<span class="hljs-number">12</span>])<br><br>        <span class="hljs-comment"># 判断最相近的颜色是否来自于数据集中已有的颜色。</span><br>        <span class="hljs-keyword">if</span> nn &lt; <span class="hljs-variable language_">self</span>.ncol:<br>            <span class="hljs-keyword">return</span> (col2, col1)  <span class="hljs-comment"># 返回(col2, col1)，即背景颜色在前，前景颜色在后。</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># need to swap to make the second color close to the input backgroun color</span><br>            <span class="hljs-keyword">return</span> (col1, col2)  <span class="hljs-comment"># 前景颜色在前，背景颜色在后。</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">mean_color</span>(<span class="hljs-params">self, arr</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        将输入图像转换为 HSV 颜色空间，并计算其所有像素点的平均颜色，最后将该颜色值转换回 RGB 空间并返回。</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用 OpenCV 的 cvtColor() 函数将 RGB 图像转换为 HSV 颜色空间。</span><br>        col = cv.cvtColor(arr, cv.COLOR_RGB2HSV)<br>        <span class="hljs-comment"># 将颜色矩阵重新塑造为一个二维数组，每一行表示一个像素点的颜色。</span><br>        col = np.reshape(col, (np.prod(col.shape[:<span class="hljs-number">2</span>]),<span class="hljs-number">3</span>))<br>        <span class="hljs-comment"># 计算颜色矩阵的均值，得到一组代表整个图像颜色的平均值，并将其转换为 8 位无符号整数(uint8)。</span><br>        col = np.mean(col,axis=<span class="hljs-number">0</span>).astype(<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>        <span class="hljs-comment"># 使用 OpenCV 的 cvtColor() 函数将 HSV 颜色空间中的颜色转换回 RGB 颜色空间，并将颜色数组压缩为一维数组，作为平均颜色的值返回。</span><br>        <span class="hljs-keyword">return</span> np.squeeze(cv.cvtColor(col[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:],cv.COLOR_HSV2RGB))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">invert</span>(<span class="hljs-params">self, rgb</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        反色</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        rgb = <span class="hljs-number">127</span> + rgb<br>        <span class="hljs-keyword">return</span> rgb<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">complement</span>(<span class="hljs-params">self, rgb_color</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        返回与给定 RGB 颜色值（rgb_color）互补的颜色</span><br><span class="hljs-string">        return a color which is complementary to the RGB_COLOR.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用 OpenCV 的 cvtColor() 函数将 RGB 颜色值转换为 HSV 颜色空间，并将颜色数组压缩为一维数组</span><br>        col_hsv = np.squeeze(cv.cvtColor(rgb_color[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:], cv.COLOR_RGB2HSV))<br>        <span class="hljs-comment"># 将HSV颜色值中的色调（Hue）加上128，实现颜色互补的效果。注意，这里的色调值需要进行取模操作，以确保它在0到255的范围内。</span><br>        col_hsv[<span class="hljs-number">0</span>] = col_hsv[<span class="hljs-number">0</span>] + <span class="hljs-number">128</span> <span class="hljs-comment">#uint8 mods to 255</span><br>        <span class="hljs-comment"># 使用 OpenCV 的 cvtColor() 函数将修改后的 HSV 值转回 RGB 颜色空间，并将颜色数组压缩为一维数组。</span><br>        col_comp = np.squeeze(cv.cvtColor(col_hsv[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:],cv.COLOR_HSV2RGB))<br>        <span class="hljs-comment"># 返回互补颜色的 RGB 值</span><br>        <span class="hljs-keyword">return</span> col_comp<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">triangle_color</span>(<span class="hljs-params">self, col1, col2</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        返回与给定两种 RGB 颜色值（col1和col2）相对应的颜色</span><br><span class="hljs-string">        计算相对颜色的方法，它接受两个表示 RGB 颜色值的参数 col1 和 col2</span><br><span class="hljs-string">        Returns a color which is &quot;opposite&quot; to both col1 and col2.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 将输入的col1和col2转换为NumPy数组。</span><br>        col1, col2 = np.array(col1), np.array(col2)<br>        <span class="hljs-comment"># 使用 OpenCV 的 cvtColor() 函数将 col1 从 RGB 颜色空间转换为 HSV 颜色空间，并将颜色数组压缩为一维数组。</span><br>        col1 = np.squeeze(cv.cvtColor(col1[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:], cv.COLOR_RGB2HSV))<br>        <span class="hljs-comment"># col2 也是</span><br>        col2 = np.squeeze(cv.cvtColor(col2[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:], cv.COLOR_RGB2HSV))<br>        <span class="hljs-comment"># 获取col1和col2的色调值（Hue）。</span><br>        h1, h2 = col1[<span class="hljs-number">0</span>], col2[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 如果 h2 小于 h1，则交换它们的值，确保 h1 始终小于等于 h2。</span><br>        <span class="hljs-keyword">if</span> h2 &lt; h1 : h1,h2 = h2,h1 <span class="hljs-comment">#swap</span><br>        <span class="hljs-comment"># 计算 h2 和 h1 之间的差值。</span><br>        dh = h2-h1<br>        <span class="hljs-comment"># 如果差值 dh 小于 127，则将 dh 设置为 255 减去 dh，实现相对颜色的计算。</span><br>        <span class="hljs-keyword">if</span> dh &lt; <span class="hljs-number">127</span>: dh = <span class="hljs-number">255</span>-dh<br>        <span class="hljs-comment"># 将 col1 的色调值设置为 h1 加上 dh 的一半，以获得相对颜色的色调值</span><br>        col1[<span class="hljs-number">0</span>] = h1 + dh/<span class="hljs-number">2</span><br>        <span class="hljs-comment"># 使用 OpenCV 的 cvtColor() 函数将修改后的HSV值转回RGB颜色空间，并将颜色数组压缩为一维数组，并返回相对颜色的RGB值</span><br>        <span class="hljs-keyword">return</span> np.squeeze(cv.cvtColor(col1[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:],cv.COLOR_HSV2RGB))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">change_value</span>(<span class="hljs-params">self, col_rgb, v_std=<span class="hljs-number">50</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        随机改变给定RGB颜色值（col_rgb）的亮度值。</span><br><span class="hljs-string">        这是一个改变颜色亮度的方法，它接受一个表示 RGB 颜色值的参数 col_rgb 和一个可选的标准差 v_std</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 使用 OpenCV 的 cvtColor() 函数将 col_rgb 从 RGB 颜色空间转换为 HSV 颜色空间，并将颜色数组压缩为一维数组。</span><br>        col = np.squeeze(cv.cvtColor(col_rgb[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:], cv.COLOR_RGB2HSV))<br>        <span class="hljs-comment"># 获取 col 的亮度值（Value）。</span><br>        x = col[<span class="hljs-number">2</span>]<br>        <span class="hljs-comment"># 生成一个从 0 到 1 均匀分布的值数组。</span><br>        vs = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 计算每个值与 x / 255.0 的差的绝对值，得到一个代表每个值与 x 的差异程度的数组。</span><br>        ps = np.<span class="hljs-built_in">abs</span>(vs - x/<span class="hljs-number">255.0</span>)<br>        <span class="hljs-comment"># 将数组 ps 归一化，使其总和等于 1</span><br>        ps /= np.<span class="hljs-built_in">sum</span>(ps)<br>        <span class="hljs-comment"># 从 vs 数组中根据权重 ps 随机选择一个值，并添加一个服从正态分布的小的随机偏移（以标准差 0.1 * v_std 为基础），然后将其限制在 0 到 1 之间。</span><br>        v_rand = np.clip(np.random.choice(vs,p=ps) + <span class="hljs-number">0.1</span>*np.random.randn(),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 将 col 的亮度值设置为 255 乘以 v_rand，以获得新的亮度值</span><br>        col[<span class="hljs-number">2</span>] = <span class="hljs-number">255</span>*v_rand<br>        <span class="hljs-keyword">return</span> np.squeeze(cv.cvtColor(col[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:],cv.COLOR_HSV2RGB))<br></code></pre></td></tr></table></figure>
<h3 id="class-colorize()" tabindex="-1" id="class-Colorize">class Colorize()</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Colorize</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, model_dir=<span class="hljs-string">&#x27;data&#x27;</span></span>):<span class="hljs-comment">#, im_path):</span><br>        <span class="hljs-comment"># 类的初始化方法，接受一个可选参数 model_dir 作为输入。</span><br>        <span class="hljs-comment"># # get a list of background-images:</span><br>        <span class="hljs-comment"># imlist = [osp.join(im_path,f) for f in os.listdir(im_path)]</span><br>        <span class="hljs-comment"># self.bg_list = [p for p in imlist if osp.isfile(p)]</span><br><br>        <span class="hljs-comment"># 创建一个 FontColor 对象，并将颜色文件的路径作为参数传递给 FontColor 类的初始化方法。这个颜色文件的路径是通过将 model_dir 和 &#x27;models/colors_new.cp&#x27; 拼接而成的。</span><br>        <span class="hljs-variable language_">self</span>.font_color = FontColor(col_file=osp.join(model_dir,<span class="hljs-string">&#x27;models/colors_new.cp&#x27;</span>))<br><br>        <span class="hljs-comment"># probabilities of different text-effects:</span><br>        <span class="hljs-comment"># add bevel effect to text 添加文字凸起效果的概率</span><br>        <span class="hljs-variable language_">self</span>.p_bevel = <span class="hljs-number">0.05</span><br>        <span class="hljs-comment"># just keep the outline of the text 只保留文字轮廓的概率</span><br>        <span class="hljs-variable language_">self</span>.p_outline = <span class="hljs-number">0.05</span><br>        <span class="hljs-comment"># 添加文字投影的概率</span><br>        <span class="hljs-variable language_">self</span>.p_drop_shadow = <span class="hljs-number">0.15</span><br>        <span class="hljs-comment"># 添加文字边框的概率</span><br>        <span class="hljs-variable language_">self</span>.p_border = <span class="hljs-number">0.15</span><br>        <span class="hljs-comment"># add background-based bump-mapping</span><br>        <span class="hljs-comment"># 基于背景添加文字的凹凸映射效果的概率</span><br>        <span class="hljs-variable language_">self</span>.p_displacement = <span class="hljs-number">0.30</span><br>        <span class="hljs-comment"># use an image for coloring text 使用图像为文字上色的概率</span><br>        <span class="hljs-variable language_">self</span>.p_texture = <span class="hljs-number">0.0</span><br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">drop_shadow</span>(<span class="hljs-params">self, alpha, theta, shift, size, op=<span class="hljs-number">0.80</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        给输入的 alpha 图像添加投影效果，并返回带有投影效果的图像。投影的效果由参数 alpha、theta、shift、size 和 op 来控制。</span><br><span class="hljs-string">        alpha : alpha layer whose shadow need to be cast</span><br><span class="hljs-string">        theta : [0,2pi] -- the shadow direction</span><br><span class="hljs-string">        shift : shift in pixels of the shadow</span><br><span class="hljs-string">        size  : size of the GaussianBlur filter</span><br><span class="hljs-string">        op    : opacity of the shadow (multiplying factor)</span><br><span class="hljs-string"></span><br><span class="hljs-string">        @return : alpha of the shadow layer</span><br><span class="hljs-string">                  (it is assumed that the color is black/white)</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> size%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>:  <span class="hljs-comment"># 如果 size 是偶数，将其减 1 以确保 size 是奇数</span><br>            size -= <span class="hljs-number">1</span><br>            size = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>,size)<br>        <span class="hljs-comment"># 使用 OpenCV 的 GaussianBlur 函数对输入的 alpha 图像进行高斯模糊，模糊核的大小为 (size, size)，标准差为 0。这样可以产生投影的模糊效果。</span><br>        shadow = cv.GaussianBlur(alpha,(size,size),<span class="hljs-number">0</span>)<br>        <span class="hljs-comment"># 根据投影的角度 theta 和平移距离 shift 计算投影在 x 和 y 方向上的偏移量。</span><br>        [dx,dy] = shift * np.array([-np.sin(theta), np.cos(theta)])<br>        <span class="hljs-comment"># 使用 scipy 库中的 shift 函数对阴影图像进行平移操作，并乘以一个 opacity 因子 op。平移的偏移量由步骤 5 计算得到。此外，设置了平移模式为 &#x27;constant&#x27;，边界填充值为 0。</span><br>        shadow = op*sii.shift(shadow, shift=[dx,dy],mode=<span class="hljs-string">&#x27;constant&#x27;</span>,cval=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> shadow.astype(<span class="hljs-string">&#x27;uint8&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">border</span>(<span class="hljs-params">self, alpha, size, kernel_type=<span class="hljs-string">&#x27;RECT&#x27;</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        alpha : alpha layer of the text</span><br><span class="hljs-string">        size  : size of the kernel</span><br><span class="hljs-string">        kernel_type : one of [rect,ellipse,cross]</span><br><span class="hljs-string"></span><br><span class="hljs-string">        @return : alpha layer of the border (color to be added externally).</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 定义了 kernel_type 和对应的形态学操作类型。</span><br>        kdict = &#123;<span class="hljs-string">&#x27;RECT&#x27;</span>:cv.MORPH_RECT, <span class="hljs-string">&#x27;ELLIPSE&#x27;</span>:cv.MORPH_ELLIPSE,<br>                 <span class="hljs-string">&#x27;CROSS&#x27;</span>:cv.MORPH_CROSS&#125;<br>        <span class="hljs-comment"># 使用 OpenCV 的 getStructuringElement 函数创建指定大小和形状的卷积核，以在 alpha 图像周围创建边框。这里的 kdict[kernel_type] 会返回 rect、ellipse 或 cross 中一个值，而 (size, size) 是指卷积核的大小。</span><br>        kernel = cv.getStructuringElement(kdict[kernel_type],(size,size))<br>        <span class="hljs-comment"># 使用 OpenCV 的 dilate 函数对输入的 alpha 图像进行膨胀操作，以使边框变得更突出。这里的 iterations=1 表示只进行一次膨胀操作。最后，减去 alpha 层，得到新的 alpha 层。这样，在文本周围会出现黑色的边框。</span><br>        border = cv.dilate(alpha,kernel,iterations=<span class="hljs-number">1</span>) <span class="hljs-comment"># - alpha</span><br>        <span class="hljs-keyword">return</span> border<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">blend</span>(<span class="hljs-params">self,cf,cb,mode=<span class="hljs-string">&#x27;normal&#x27;</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        在这个方法中，函数只返回了前景图像。这表明该函数还没有完成或者是开发者忘记编写具体的合成算法。</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> cf<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_two</span>(<span class="hljs-params">self,fore,back,blend_type=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        merge two FOREground and BACKground layers.</span><br><span class="hljs-string">        ref: https://en.wikipedia.org/wiki/Alpha_compositing</span><br><span class="hljs-string">        ref: Chapter 7 (pg. 440 and pg. 444):</span><br><span class="hljs-string">             http://partners.adobe.com/public/developer/en/pdf/PDFReference.pdf</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 将前景图层的 alpha 通道值转换为范围在 0 到 1 之间的浮点数，表示不透明度</span><br>        a_f = fore.alpha/<span class="hljs-number">255.0</span><br>        <span class="hljs-comment"># 将背景图层的 alpha 通道值转换为范围在 0 到 1 之间的浮点数，表示不透明度</span><br>        a_b = back.alpha/<span class="hljs-number">255.0</span><br>        <span class="hljs-comment"># 获取前景图层的颜色通道值</span><br>        c_f = fore.color<br>        <span class="hljs-comment"># 获取背景图层的颜色通道值</span><br>        c_b = back.color<br>        <span class="hljs-comment"># 根据 Alpha 合成公式计算新的合成后的图像的 alpha 值</span><br>        a_r = a_f + a_b - a_f*a_b<br>        <span class="hljs-keyword">if</span> blend_type != <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># 使用之前提到的 blend() 方法将前景和背景的颜色进行合成，得到混合后的颜色</span><br>            c_blend = <span class="hljs-variable language_">self</span>.blend(c_f, c_b, blend_type)<br>            <span class="hljs-comment"># 以混合后的颜色为基础，按照 Alpha 合成公式计算新的合成后的图像的颜色值</span><br>            c_r = (   ((<span class="hljs-number">1</span>-a_f)*a_b)[:,:,<span class="hljs-literal">None</span>] * c_b<br>                    + ((<span class="hljs-number">1</span>-a_b)*a_f)[:,:,<span class="hljs-literal">None</span>] * c_f<br>                    + (a_f*a_b)[:,:,<span class="hljs-literal">None</span>] * c_blend   )<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># c_r 的计算只根据前景和背景的颜色以及各自的不透明度进行合成</span><br>            c_r = (   ((<span class="hljs-number">1</span>-a_f)*a_b)[:,:,<span class="hljs-literal">None</span>] * c_b<br>                    + a_f[:,:,<span class="hljs-literal">None</span>]*c_f    )<br>        <span class="hljs-comment"># 返回一个新的图层对象，其中包含合成后的图像的 alpha 和颜色通道值</span><br>        <span class="hljs-keyword">return</span> Layer((<span class="hljs-number">255</span>*a_r).astype(<span class="hljs-string">&#x27;uint8&#x27;</span>), c_r.astype(<span class="hljs-string">&#x27;uint8&#x27;</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">merge_down</span>(<span class="hljs-params">self, layers, blends=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        将多个图层逐层合并成单个图层</span><br><span class="hljs-string">        layers  : [l1,l2,...ln] : a list of LAYER objects.</span><br><span class="hljs-string">                 l1 is on the top, ln is the bottom-most layer.</span><br><span class="hljs-string">        blend   : the type of blend to use. Should be n-1.</span><br><span class="hljs-string">                 use None for plain alpha blending.</span><br><span class="hljs-string">        Note    : (1) it assumes that all the layers are of the SAME SIZE.</span><br><span class="hljs-string">        @return : a single LAYER type object representing the merged-down image</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        nlayers = <span class="hljs-built_in">len</span>(layers)  <span class="hljs-comment"># 获取图层数量</span><br>        <span class="hljs-keyword">if</span> nlayers &gt; <span class="hljs-number">1</span>:  <span class="hljs-comment"># 检查是否有多个图层需要合并</span><br>            [n,m] = layers[<span class="hljs-number">0</span>].alpha.shape[:<span class="hljs-number">2</span>]  <span class="hljs-comment"># 获取第一个图层的尺寸</span><br>            out_layer = layers[-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 初始化输出图层为最底层的图层</span><br>            <span class="hljs-comment"># 从倒数第二个图层开始循环遍历，直到最顶层的图层</span><br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(-<span class="hljs-number">2</span>,-nlayers-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>):<br>                blend=<span class="hljs-literal">None</span><br>                <span class="hljs-keyword">if</span> blends <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    blend = blends[i+<span class="hljs-number">1</span>]<br>                    out_layer = <span class="hljs-variable language_">self</span>.merge_two(fore=layers[i], back=out_layer,blend_type=blend)<br>            <span class="hljs-keyword">return</span> out_layer<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> layers[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">resize_im</span>(<span class="hljs-params">self, im, osize</span>):<br>        <span class="hljs-comment"># 将输入的图像调整为指定的大小</span><br>        <span class="hljs-keyword">return</span> np.array(Image.fromarray(im).resize(osize[::-<span class="hljs-number">1</span>], Image.BICUBIC))<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">occlude</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        somehow add occlusion to text.</span><br><span class="hljs-string">        这个方法 occlude() 是一个占位方法，还未实现其具体功能。</span><br><span class="hljs-string"></span><br><span class="hljs-string">        根据注释中的描述，该方法的目的是向文本中添加遮挡效果。然而，在代码中该方法没有任何实现，只有一个空的 pass 语句。这意味着在当前的代码实现中，该方法没有具体的功能。</span><br><span class="hljs-string"></span><br><span class="hljs-string">        如果你希望实现该方法，你可以根据具体需求和设计思路，编写代码来实现添加遮挡效果的逻辑。例如，可以使用图像处理技术在文本区域上添加遮挡元素，或者通过修改文本的视觉特征来模拟遮挡效果。具体的实现方式取决于你的需求和想要实现的效果。</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">color_border</span>(<span class="hljs-params">self, col_text, col_bg</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        用于确定边框的颜色的选择逻辑</span><br><span class="hljs-string">        Decide on a color for the border:</span><br><span class="hljs-string">            - could be the same as text-color but lower/higher &#x27;VALUE&#x27; component. 边框颜色与文本颜色相同，但是 &#x27;VALUE&#x27; 分量较低或较高</span><br><span class="hljs-string">            - could be the same as bg-color but lower/higher &#x27;VALUE&#x27;. 边框颜色与背景颜色相同，但是 &#x27;VALUE&#x27; 分量较低或较高</span><br><span class="hljs-string">            - could be &#x27;mid-way&#x27; color b/w text &amp; bg colors. 边框颜色为文本颜色和背景颜色之间的中间颜色。</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 随机选择一个数字，范围是 0 到 2，用于决定使用哪种方式选择边框颜色</span><br>        choice = np.random.choice(<span class="hljs-number">3</span>)<br>		<span class="hljs-comment"># 将输入的文本颜色 col_text 转换为 HSV 格式，以便于处理颜色的亮度等特征</span><br>        col_text = cv.cvtColor(col_text, cv.COLOR_RGB2HSV)<br>        <span class="hljs-comment"># 将 col_text 变形为一维数组，并计算其均值，得到颜色的平均值</span><br>        col_text = np.reshape(col_text, (np.prod(col_text.shape[:<span class="hljs-number">2</span>]),<span class="hljs-number">3</span>))<br>        col_text = np.mean(col_text,axis=<span class="hljs-number">0</span>).astype(<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>		<span class="hljs-comment"># 通过线性插值，定义了一个从 0 到 1 的值序列，用于生成随机样本</span><br>        vs = np.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sample</span>(<span class="hljs-params">x</span>):<br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            通过计算与目标值 x/255.0 的差距，选择一个随机样本，并在其上加入一定的随机扰动。返回取样结果乘以 255，得到一个颜色分量值。</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            ps = np.<span class="hljs-built_in">abs</span>(vs - x/<span class="hljs-number">255.0</span>)<br>            ps /= np.<span class="hljs-built_in">sum</span>(ps)<br>            v_rand = np.clip(np.random.choice(vs,p=ps) + <span class="hljs-number">0.1</span>*np.random.randn(),<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">255</span>*v_rand<br><br>        <span class="hljs-comment"># first choose a color, then inc/dec its VALUE:</span><br>        <span class="hljs-comment"># 根据选择的方式进行不同的处理</span><br>        <span class="hljs-keyword">if</span> choice==<span class="hljs-number">0</span>:<br>            <span class="hljs-comment"># increase/decrease saturation:</span><br>            <span class="hljs-comment"># 增加或减少饱和度</span><br>            col_text[<span class="hljs-number">0</span>] = get_sample(col_text[<span class="hljs-number">0</span>]) <span class="hljs-comment"># saturation</span><br>            col_text = np.squeeze(cv.cvtColor(col_text[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:],cv.COLOR_HSV2RGB))<br>        <span class="hljs-keyword">elif</span> choice==<span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># get the complementary color to text:</span><br>            <span class="hljs-comment"># 获取文本颜色的互补色</span><br>            col_text = np.squeeze(cv.cvtColor(col_text[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:],cv.COLOR_HSV2RGB))<br>            col_text = <span class="hljs-variable language_">self</span>.font_color.complement(col_text)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># choose a mid-way color:</span><br>            <span class="hljs-comment"># 选择文本颜色和背景颜色的中间颜色</span><br>            col_bg = cv.cvtColor(col_bg, cv.COLOR_RGB2HSV)<br>            col_bg = np.reshape(col_bg, (np.prod(col_bg.shape[:<span class="hljs-number">2</span>]),<span class="hljs-number">3</span>))<br>            col_bg = np.mean(col_bg,axis=<span class="hljs-number">0</span>).astype(<span class="hljs-string">&#x27;uint8&#x27;</span>)<br>            col_bg = np.squeeze(cv.cvtColor(col_bg[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:],cv.COLOR_HSV2RGB))<br>            col_text = np.squeeze(cv.cvtColor(col_text[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:],cv.COLOR_HSV2RGB))<br>            col_text = <span class="hljs-variable language_">self</span>.font_color.triangle_color(col_text,col_bg)<br><br>        <span class="hljs-comment"># now change the VALUE channel:     </span><br>        <span class="hljs-comment"># 将处理后的颜色转换为 HSV 格式，并修改亮度通道的值。</span><br>        col_text = np.squeeze(cv.cvtColor(col_text[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:],cv.COLOR_RGB2HSV))<br>        col_text[<span class="hljs-number">2</span>] = get_sample(col_text[<span class="hljs-number">2</span>]) <span class="hljs-comment"># value</span><br>        <span class="hljs-comment"># 最后，将处理后的颜色转换为 RGB 格式，并返回结果</span><br>        <span class="hljs-keyword">return</span> np.squeeze(cv.cvtColor(col_text[<span class="hljs-literal">None</span>,<span class="hljs-literal">None</span>,:],cv.COLOR_HSV2RGB))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">color_text</span>(<span class="hljs-params">self, text_arr, h, bg_arr</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        用于确定文本的颜色。具体而言，该方法采用以下几种方式之一来选择文本的颜色</span><br><span class="hljs-string">        Decide on a color for the text:</span><br><span class="hljs-string">            - could be some other random image. 从其他随机图像中选择一个颜色作为文本的颜色</span><br><span class="hljs-string">            - could be a color based on the background. 根据背景选择一个颜色</span><br><span class="hljs-string">                this color is sampled from a dictionary built</span><br><span class="hljs-string">                from text-word images&#x27; colors. The VALUE channel</span><br><span class="hljs-string">                is randomized.</span><br><span class="hljs-string">                这个颜色是从建立在文本单词图像颜色上的字典中进行采样的。其中，颜色的亮度通道 (VALUE) 是随机化的</span><br><span class="hljs-string"></span><br><span class="hljs-string">            H : minimum height of a character</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 定义变量，用于存储背景色和文本颜色</span><br>        bg_col,fg_col,i = <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span><br>        <span class="hljs-comment"># 从文本单词图像颜色构建的字典中采样一个颜色作为文本颜色，并将结果分别赋值给 fg_col 和 bg_col</span><br>        fg_col,bg_col = <span class="hljs-variable language_">self</span>.font_color.sample_from_data(bg_arr)<br>        <span class="hljs-comment"># 创建一个 Layer 对象，将 text_arr 作为透明度 (alpha) 通道，将 fg_col 作为颜色 (color) 通道，并返回该对象以及 fg_col 和 bg_col</span><br>        <span class="hljs-keyword">return</span> Layer(alpha=text_arr, color=fg_col), fg_col, bg_col<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process</span>(<span class="hljs-params">self, text_arr, bg_arr, min_h</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        用于将文本图层 text_arr 融合到背景图像 bg_arr 上</span><br><span class="hljs-string">        text_arr : one alpha mask : nxm, uint8</span><br><span class="hljs-string">        bg_arr   : background image: nxmx3, uint8</span><br><span class="hljs-string">        min_h    : height of the smallest character (px)</span><br><span class="hljs-string"></span><br><span class="hljs-string">        return text_arr blit onto bg_arr.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># decide on a color for the text:</span><br>        <span class="hljs-comment"># 调用 color_text 方法确定文本的颜色，并将结果的透明度通道 l_text、文本颜色 fg_col 和背景颜色 bg_col 分别赋值给变量</span><br>        l_text, fg_col, bg_col = <span class="hljs-variable language_">self</span>.color_text(text_arr, min_h, bg_arr)<br>        <span class="hljs-comment"># 根据文本的透明度通道 l_text.alpha 构建一个新的图层 l_bg，其中颜色通道为 bg_col</span><br>        bg_col = np.mean(np.mean(bg_arr,axis=<span class="hljs-number">0</span>),axis=<span class="hljs-number">0</span>)<br>        l_bg = Layer(alpha=<span class="hljs-number">255</span>*np.ones_like(text_arr,<span class="hljs-string">&#x27;uint8&#x27;</span>),color=bg_col)<br>        <span class="hljs-comment"># 将 l_text 的透明度乘以一个随机化的权重，并将结果限制在 0.72 到 1.0 之间</span><br>        l_text.alpha = l_text.alpha * np.clip(<span class="hljs-number">0.88</span> + <span class="hljs-number">0.1</span>*np.random.randn(), <span class="hljs-number">0.72</span>, <span class="hljs-number">1.0</span>)<br>        layers = [l_text]<br>        blends = []<br><br>        <span class="hljs-comment"># add border:</span><br>        <span class="hljs-keyword">if</span> np.random.rand() &lt; <span class="hljs-variable language_">self</span>.p_border:<br>            <span class="hljs-comment"># 根据最小高度 min_h 确定边界的大小 bsz</span><br>            <span class="hljs-keyword">if</span> min_h &lt;= <span class="hljs-number">15</span> : bsz = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> <span class="hljs-number">15</span> &lt; min_h &lt; <span class="hljs-number">30</span>: bsz = <span class="hljs-number">3</span><br>            <span class="hljs-keyword">else</span>: bsz = <span class="hljs-number">5</span><br>            border_a = <span class="hljs-variable language_">self</span>.border(l_text.alpha, size=bsz)<br>            <span class="hljs-comment"># 使用 border 方法创建一个边界图层 l_border，其中边界的透明度为 l_text.alpha，颜色为根据 l_text.color 和 l_bg.color 确定的边界颜色</span><br>            l_border = Layer(border_a, <span class="hljs-variable language_">self</span>.color_border(l_text.color,l_bg.color))<br>            <span class="hljs-comment"># 将 l_border 加入 layers 列表，并将 &#x27;normal&#x27; 加入 blends 列表</span><br>            layers.append(l_border)<br>            blends.append(<span class="hljs-string">&#x27;normal&#x27;</span>)<br><br>        <span class="hljs-comment"># add shadow:</span><br>        <span class="hljs-comment"># 如果随机数小于 p_drop_shadow（可能是一个阴影的概率）:</span><br>        <span class="hljs-keyword">if</span> np.random.rand() &lt; <span class="hljs-variable language_">self</span>.p_drop_shadow:<br>            <span class="hljs-comment"># shadow gaussian size:</span><br>            <span class="hljs-comment"># 根据最小高度 min_h 确定阴影的大小 bsz</span><br>            <span class="hljs-keyword">if</span> min_h &lt;= <span class="hljs-number">15</span> : bsz = <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> <span class="hljs-number">15</span> &lt; min_h &lt; <span class="hljs-number">30</span>: bsz = <span class="hljs-number">3</span><br>            <span class="hljs-keyword">else</span>: bsz = <span class="hljs-number">5</span><br><br>            <span class="hljs-comment"># shadow angle: 随机选择阴影的角度</span><br>            theta = np.pi/<span class="hljs-number">4</span> * np.random.choice([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>]) + <span class="hljs-number">0.5</span>*np.random.randn()<br><br>            <span class="hljs-comment"># shadow shift: 根据最小高度 min_h 确定阴影的偏移量 shift</span><br>            <span class="hljs-keyword">if</span> min_h &lt;= <span class="hljs-number">15</span> : shift = <span class="hljs-number">2</span><br>            <span class="hljs-keyword">elif</span> <span class="hljs-number">15</span> &lt; min_h &lt; <span class="hljs-number">30</span>: shift = <span class="hljs-number">7</span>+np.random.randn()<br>            <span class="hljs-keyword">else</span>: shift = <span class="hljs-number">15</span> + <span class="hljs-number">3</span>*np.random.randn()<br><br>            <span class="hljs-comment"># opacity: 根据最小高度 min_h 确定阴影的不透明度 op</span><br>            op = <span class="hljs-number">0.50</span> + <span class="hljs-number">0.1</span>*np.random.randn()<br>            <span class="hljs-comment"># 使用 drop_shadow 方法创建一个阴影图层 l_shadow，其中阴影的透明度为 l_text.alpha，颜色为 0</span><br>            shadow = <span class="hljs-variable language_">self</span>.drop_shadow(l_text.alpha, theta, shift, <span class="hljs-number">3</span>*bsz, op)<br>            l_shadow = Layer(shadow, <span class="hljs-number">0</span>)<br>            <span class="hljs-comment"># 将 l_shadow 加入 layers 列表，并将 &#x27;normal&#x27; 加入 blends 列表</span><br>            layers.append(l_shadow)<br>            blends.append(<span class="hljs-string">&#x27;normal&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 创建一个新的图层 l_bg，颜色通道为 bg_arr</span><br>        l_bg = Layer(alpha=<span class="hljs-number">255</span>*np.ones_like(text_arr,<span class="hljs-string">&#x27;uint8&#x27;</span>), color=bg_col)<br>        <span class="hljs-comment"># 将 l_bg 加入 layers 列表，并将 &#x27;normal&#x27; 加入 blends 列表</span><br>        layers.append(l_bg)<br>        blends.append(<span class="hljs-string">&#x27;normal&#x27;</span>)<br>        <span class="hljs-comment"># 将所有图层融合成一个图层</span><br>        l_normal = <span class="hljs-variable language_">self</span>.merge_down(layers,blends)<br>        <span class="hljs-comment"># now do poisson image editing: 使用泊松图像编辑算法</span><br>        l_bg = Layer(alpha=<span class="hljs-number">255</span>*np.ones_like(text_arr,<span class="hljs-string">&#x27;uint8&#x27;</span>), color=bg_arr)<br>        l_out =  blit_images(l_normal.color,l_bg.color.copy())<br>        <br>        <span class="hljs-comment"># plt.subplot(1,3,1)</span><br>        <span class="hljs-comment"># plt.imshow(l_normal.color)</span><br>        <span class="hljs-comment"># plt.subplot(1,3,2)</span><br>        <span class="hljs-comment"># plt.imshow(l_bg.color)</span><br>        <span class="hljs-comment"># plt.subplot(1,3,3)</span><br>        <span class="hljs-comment"># plt.imshow(l_out)</span><br>        <span class="hljs-comment"># plt.show()</span><br>        <br>        <span class="hljs-comment"># 如果融合后的图像 l_out 为 None，则将最后一个图层 l_bg 替换为 l_bg，并返回最终融合后的图像颜色</span><br>        <span class="hljs-keyword">if</span> l_out <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-comment"># poisson recontruction produced</span><br>            <span class="hljs-comment"># imperceptible text. In this case,</span><br>            <span class="hljs-comment"># just do a normal blend:</span><br>            layers[-<span class="hljs-number">1</span>] = l_bg<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.merge_down(layers,blends).color<br><br>        <span class="hljs-keyword">return</span> l_out<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_perceptible</span>(<span class="hljs-params">self, txt_mask, bg, txt_bg</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        这是一个被弃用的方法 check_perceptible，它用于检查文本与背景图像合并后是否仍然可见。</span><br><span class="hljs-string">        --- DEPRECATED; USE GRADIENT CHECKING IN POISSON-RECONSTRUCT INSTEAD ---</span><br><span class="hljs-string"></span><br><span class="hljs-string">        checks if the text after merging with background</span><br><span class="hljs-string">        is still visible.</span><br><span class="hljs-string">        txt_mask (hxw) : binary image of text -- 255 where text is present</span><br><span class="hljs-string">                                                   0 elsewhere</span><br><span class="hljs-string">        bg (hxwx3) : original background image WITHOUT any text.</span><br><span class="hljs-string">        txt_bg (hxwx3) : image with text.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        bgo,txto = bg.copy(), txt_bg.copy()<br>        txt_mask = txt_mask.astype(<span class="hljs-string">&#x27;bool&#x27;</span>)<br>        bg = cv.cvtColor(bg.copy(), cv.COLOR_RGB2Lab)<br>        txt_bg = cv.cvtColor(txt_bg.copy(), cv.COLOR_RGB2Lab)<br>        bg_px = bg[txt_mask,:]<br>        txt_px = txt_bg[txt_mask,:]<br>        bg_px[:,<span class="hljs-number">0</span>] *= <span class="hljs-number">100.0</span>/<span class="hljs-number">255.0</span> <span class="hljs-comment">#rescale - L channel</span><br>        txt_px[:,<span class="hljs-number">0</span>] *= <span class="hljs-number">100.0</span>/<span class="hljs-number">255.0</span><br><br>        diff = np.linalg.norm(bg_px-txt_px,<span class="hljs-built_in">ord</span>=<span class="hljs-literal">None</span>,axis=<span class="hljs-number">1</span>)<br>        diff = np.percentile(diff,[<span class="hljs-number">10</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,<span class="hljs-number">70</span>,<span class="hljs-number">90</span>])<br>        <span class="hljs-built_in">print</span> (<span class="hljs-string">&quot;color diff percentile :&quot;</span>, diff)<br>        <span class="hljs-keyword">return</span> diff, (bgo,txto)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">color</span>(<span class="hljs-params">self, bg_arr, text_arr, hs, place_order=<span class="hljs-literal">None</span>, pad=<span class="hljs-number">20</span></span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        将文本图像着色</span><br><span class="hljs-string">        Return colorized text image.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        text_arr : list of (n x m) numpy text alpha mask (unit8).</span><br><span class="hljs-string">        hs : list of minimum heights (scalar) of characters in each text-array. </span><br><span class="hljs-string">        text_loc : [row,column] : location of text in the canvas.</span><br><span class="hljs-string">        canvas_sz : size of canvas image.</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        return : nxmx3 rgb colorized text-image.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 复制输入的背景图像</span><br>        bg_arr = bg_arr.copy()<br>        <span class="hljs-comment"># 如果背景图像是灰度图像（二维）或单通道图像（shape[2] == 1），则将其转换为三通道图像</span><br>        <span class="hljs-keyword">if</span> bg_arr.ndim == <span class="hljs-number">2</span> <span class="hljs-keyword">or</span> bg_arr.shape[<span class="hljs-number">2</span>]==<span class="hljs-number">1</span>: <span class="hljs-comment"># grayscale image:</span><br>            bg_arr = np.repeat(bg_arr[:,:,<span class="hljs-literal">None</span>], <span class="hljs-number">3</span>, <span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># get the canvas size:</span><br>        <span class="hljs-comment"># 获取背景图像的尺寸</span><br>        canvas_sz = np.array(bg_arr.shape[:<span class="hljs-number">2</span>])<br><br>        <span class="hljs-comment"># initialize the placement order:</span><br>        <span class="hljs-comment"># 初始化放置文本的顺序</span><br>        <span class="hljs-keyword">if</span> place_order <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            place_order = np.array(<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(text_arr)))<br><br>        rendered = []<br>        <span class="hljs-comment"># 对每个文本数组进行处理</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> place_order[::-<span class="hljs-number">1</span>]:<br>            <span class="hljs-comment"># get the &quot;location&quot; of the text in the image:</span><br>            <span class="hljs-comment"># this is the minimum x and y coordinates of text:</span><br>            <span class="hljs-comment"># 获取文本在图像中的位置。</span><br>            loc = np.where(text_arr[i])<br>            <span class="hljs-comment"># 计算文本区域的最小点和最大点，并计算出文本区域的宽度和高度</span><br>            lx, ly = np.<span class="hljs-built_in">min</span>(loc[<span class="hljs-number">0</span>]), np.<span class="hljs-built_in">min</span>(loc[<span class="hljs-number">1</span>])<br>            mx, my = np.<span class="hljs-built_in">max</span>(loc[<span class="hljs-number">0</span>]), np.<span class="hljs-built_in">max</span>(loc[<span class="hljs-number">1</span>])<br>            l = np.array([lx,ly])<br>            m = np.array([mx,my])-l+<span class="hljs-number">1</span><br>            text_patch = text_arr[i][l[<span class="hljs-number">0</span>]:l[<span class="hljs-number">0</span>]+m[<span class="hljs-number">0</span>],l[<span class="hljs-number">1</span>]:l[<span class="hljs-number">1</span>]+m[<span class="hljs-number">1</span>]]<br><br>            <span class="hljs-comment"># figure out padding:</span><br>            ext = canvas_sz - (l+m)<br>            num_pad = pad*np.ones(<span class="hljs-number">4</span>,dtype=<span class="hljs-string">&#x27;int32&#x27;</span>)<br>            num_pad[:<span class="hljs-number">2</span>] = np.minimum(num_pad[:<span class="hljs-number">2</span>], l)<br>            num_pad[<span class="hljs-number">2</span>:] = np.minimum(num_pad[<span class="hljs-number">2</span>:], ext)<br>            text_patch = np.pad(text_patch, pad_width=((num_pad[<span class="hljs-number">0</span>],num_pad[<span class="hljs-number">2</span>]), (num_pad[<span class="hljs-number">1</span>],num_pad[<span class="hljs-number">3</span>])), mode=<span class="hljs-string">&#x27;constant&#x27;</span>)<br>            l -= num_pad[:<span class="hljs-number">2</span>]<br><br>            w,h = text_patch.shape<br>            bg = bg_arr[l[<span class="hljs-number">0</span>]:l[<span class="hljs-number">0</span>]+w,l[<span class="hljs-number">1</span>]:l[<span class="hljs-number">1</span>]+h,:]<br><br>            <span class="hljs-comment"># 使用方法 process 对文本进行着色处理，返回着色后的文本图像</span><br>            rdr0 = <span class="hljs-variable language_">self</span>.process(text_patch, bg, hs[i])<br>            rendered.append(rdr0)<br><br>            <span class="hljs-comment"># 将着色后的文本图像放回到背景图像的相应位置</span><br>            bg_arr[l[<span class="hljs-number">0</span>]:l[<span class="hljs-number">0</span>]+w,l[<span class="hljs-number">1</span>]:l[<span class="hljs-number">1</span>]+h,:] = rdr0<span class="hljs-comment">#rendered[-1]</span><br><br>			<span class="hljs-comment"># 返回最终的背景图像</span><br>            <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">            需要注意的是，当前代码中存在一个问题，即在 for 循环中的最后一行使用了 return，导致循环只执行一次。可能是由于代码缩进错误导致的。如果确实需要返回结果，则应将该行移动到 for 循环结束后再执行。</span><br><span class="hljs-string">            &quot;&quot;&quot;</span><br>            <span class="hljs-keyword">return</span> bg_arr<br><br>        <span class="hljs-keyword">return</span> bg_arr<br></code></pre></td></tr></table></figure>

            </article>
            
	<div class="rightside">
	
		<div class="rightside-button" id="js-aside">
			<span>
				<img no-lazy src="/images/icon/aside.png" class="rightside-button-icon" alt="Icon">
			</span>
		</div>
		<script>
			$("#js-aside").click(function () {
				onShowAsideButton();
			});
		</script>
	
	<div class="rightside-button" id="js-toggle_theme">
		<span>
			<img no-lazy src="/images/icon/toggle_theme.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>

	
<script src="/js/plugins/goto_position.js"></script>

	
	<div class="rightside-button" id="js-go_top">
		<span>
			<img no-lazy src="/images/icon/go_top.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>
	<div class="rightside-button" id="js-go_bottom">
		<span>
			<img no-lazy src="/images/icon/go_bottom.png" class="rightside-button-icon" alt="Icon">
		</span>
	</div>

	<script>
		setToggleThemeButtonListener();
	</script>
	<script>
		$('#js-go_top')
		.gotoPosition( {
			speed: 300,
			target: 'top',
		} );
		$('#js-go_bottom')
		.gotoPosition( {
			speed: 300,
			target: 'bottom',
		} );
	</script>
</div>


<div class="post-bottom">
    
        <div class="post-paging">     
            <div class="post-paging-last">
                
                    <a href="/posts/Software-PS%20Beta%2025.0/">
                        上一篇：Software-PS Beta 25.0
                    </a>
                
            </div>
            <div class="post-paging-next">
                
                    <a href="/posts/Diary-%E5%8F%88%E9%B9%AD%E4%BA%86%EF%BC%8C%E5%8F%88%E5%8F%88%E5%86%80%E4%BA%86/">
                        下一篇：Diary-又鹭了，又又冀了
                    </a>
                
            </div>
        </div>
    
    
    
        
            <div class="giscus comments"></div>
            <script>
                var scriptElement = document.createElement('script');
                scriptElement.src = 'https://giscus.app/client.js';
                scriptElement.setAttribute('data-repo', 'GZ-Metal-Cell/GZ-Metal-Cell.github.io');
                scriptElement.setAttribute('data-repo-id', 'R_kgDOIHLEOQ');
                scriptElement.setAttribute('data-category', 'Announcements');
                scriptElement.setAttribute('data-category-id', 'DIC_kwDOIHLEOc4CcVwP');
                scriptElement.setAttribute('data-mapping', 'title');
                scriptElement.setAttribute('data-strict', '1');
                scriptElement.setAttribute('data-reactions-enabled', '');
                scriptElement.setAttribute('data-emit-metadata', '0');
                scriptElement.setAttribute('data-input-position', 'bottom');
                scriptElement.setAttribute('data-theme', localStorage.getItem('theme') === 'light' ? 'light' : 'dark_high_contrast');
                scriptElement.setAttribute('data-lang', 'zh-CN');
                
                scriptElement.setAttribute('crossorigin', 'anonymous');
                scriptElement.async = true;
                document.head.appendChild(scriptElement);
            </script>
        
    
</div>
        </div>
    </main>
    
        <aside class="main-aside">
    
<script src="/js/widgets/aside.js"></script>

    <script>
        showAside();
    </script>

    <div class="aside-top">
        <div class="aside-top-about aside-card">
            <a href="/about" class="aside-top-about-portrait">
                <img no-lazy src="/about/portrait.png" alt="Q">
            </a>
            <div class="aside-top-about-info">
                <span class="author"> Zi-Zi</span>
                <span class="description">不以物喜，不以己悲。</span>
            </div>              
            <div class="aside-top-about-site">
                <a href="/categories" class="aside-top-about-site-item">
                    <span class="title">类别</span>
                    <span class="count">5</span>
                </a>
                <a href="/tags" class="aside-top-about-site-item">
                    <span class="title">标签</span>
                    <span class="count">120</span>
                </a>
                <a href="/archives" class="aside-top-about-site-item">
                    <span class="title">归档</span>
                    <span class="count">435</span>
                </a>
            </div>
            <div class="aside-top-about-contact">
                
                    
                        <a target="_blank" rel="noopener" href="https://weibo.com/u/5020307235">
                            <img no-lazy src="/images/bottom_icon/Weibo.webp" alt="Quieter">
                        </a>
                    
                        <a target="_blank" rel="noopener" href="https://tieba.baidu.com/home/main?id=tb.1.ff6d2775.vFH7wrdW2ZjPCmyBHJcjnA">
                            <img no-lazy src="/images/bottom_icon/Tieba.webp" alt="Quieter">
                        </a>
                    
                        <a target="_blank" rel="noopener" href="https://space.bilibili.com/11547880">
                            <img no-lazy src="/images/bottom_icon/Bilibili.webp" alt="Quieter">
                        </a>
                    
                        <a target="_blank" rel="noopener" href="https://github.com/GZ-Metal-Cell">
                            <img no-lazy src="/images/bottom_icon/github.webp" alt="Quieter">
                        </a>
                    
                
            </div>
        </div> 

        
    </div>

    <div class="aside-bottom">
        
            <script>
                
                    const tocCollapsed = true;
                
                
                    const tocDepth = 6;
                
                var headerString = '';
                for (let i = 1; i <= tocDepth; i++) {
                    if (i === 1) {
                        headerString += 'h1';
                    } else {
                        headerString += ', h' + i;
                    }
                }
                hbeToc();
            </script>
            <div class="aside-bottom-toc aside-card">
                <div class="aside-bottom-toc-title">
                    <h1>目录</h1>
                    <span class="toc-percentage"></span>
                </div>
                <ol class="aside-bottom-toc-content"></ol>
            </div>
        
    </div>
</aside>
    
</div>
		<footer>
	<div class="content">
		
			<span>©2022-2025&nbsp;By&nbsp;<a href="/about">Zi-Zi</a>.</span>
		
		<span><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a> theme by <a target="_blank" rel="noopener" href="https://github.com/GZ-Metal-Cell/hexo-theme-quieter">Quieter</a>.</span>
		
			<span style="display: flex;">
				<img no-lazy alt="icp" src="/images/icp_icon.png" style="width: 16px; height: 16px;">
				<a href="https://icp.gov.moe/?keyword=20241647" target="_blank">萌 ICP 备 20241647 号</a>
			</span>
		
	</div>

	
<script src="/js/plugins/ref.js"></script>

	
<script src="/js/plugins/highlight_tools.js"></script>

	<script>
		const  COPY_ICON = "/images/icon/copy.png";
		const CLOSE_CODE_BLOCK_ICON = "/images/icon/close_code_block.png";
		const HIGHLIGHT_SHRINK = "";
		const HIGHLIGHT_HEIGHT_LIMIT = "";
	</script>

	
	
	<!-- Analytics -->

    
        <!-- Busuanzi Analytics -->
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
        <!-- Baidu Analytics -->
        <script defer>
            var _hmt = _hmt || [];
            (function () {
                var hm = document.createElement("script");
                hm.src = "https://hm.baidu.com/hm.js?e57cf62289f84322ebff116e8b3d343e";
                var s = document.getElementsByTagName("script")[0];
                s.parentNode.insertBefore(hm, s);
            })();
        </script>
    


	

	
		
			
				<link rel="stylesheet" href="/css/plugins/katex/katex.min.css">
				<script src="/js/plugins/copy-tex.js"></script>
			
		
	

    
		
<link rel="stylesheet" href="/css/plugins/textIndent.css">

		
<script src="/js/plugins/textIndent.js"></script>

	

	
	
	
		<script>
			if (typeof init === 'function') {
				init();
			}
		</script>
	

	
		
	

	

	<!--
		
<script src="/js/plugins/jquery.pjax.min.js"></script>

		<script>
			$(document).pjax('a[target!=_blank]', 'main', {
				fragment: 'main',
				timeout: 8000
			});

			$(document).on('pjax:complete', function() {
			});
		</script> 
	-->
	<script>
		console.log('\n %c Hexo-Quieter 主题 %c https://github.com/GZ-Metal-Cell/hexo-theme-quieter \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
	</script>
</footer>
	</body>

	<!-- Hexo-Quieter 主题  https://github.com/GZ-Metal-Cell/hexo-theme-quieter -->
</html>

